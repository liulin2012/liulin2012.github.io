<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Lin]]></title>
  <subtitle><![CDATA[More code , Have fun]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-10-21T16:26:22.247Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[lin liu]]></name>
    <email><![CDATA[liulin.jacob@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[My Introduction to Algorithms(CLRS) Notes]]></title>
    <link href="http://yoursite.com/2015/10/20/My-Introduction-to-Algorithms-CLRS-Notes/"/>
    <id>http://yoursite.com/2015/10/20/My-Introduction-to-Algorithms-CLRS-Notes/</id>
    <published>2015-10-21T01:39:43.000Z</published>
    <updated>2015-10-21T16:23:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Overview">Overview</h2>
<p>It takes me half year to finish the CLRS and learn a lot. This is my notes about the legendary book.</p>
<p>I have read the whole book and take the online <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/" target="_blank" rel="external">MIT open Course</a>. Thanks MIT for the online course.<br>I’ve also get resource from Chinese and English forum.</p>
<p>I want to share my note to other guy who is interested in the algorithm and thinking.<br>Please feel free to check it out. Hope it’s helpful to you. Thank you.</p>
<a id="more"></a>
<h2 id="Math">Math</h2>
<h3 id="Master_theorem">Master theorem</h3>
<p>证明递归式的算法复杂度<br><img src="http://i.imgur.com/CWyQle2.png" alt="Alt text"></p>
<h3 id="Geometric_progression">Geometric progression</h3>
<p>可用于递归树<br><img src="http://i.imgur.com/4f5Q6NB.png" alt="Alt text"></p>
<h3 id="Recursion_tree">Recursion tree</h3>
<p>求出每层的操作代价，相加，一般可能是等比数列，求等比数列。</p>
<p>例子：$T(n) = T(n/4) + T(n/2) + n^2$<br>第一行  $ n^2$<br>第二行   $\dfrac{5}{16} n^2$<br>第三行  $\dfrac{25}{256} n^2$<br>……</p>
<p>利用等比数列求和公式算出大O为&lt;$2n^2$<br>所以算法复杂度为$n^2$<br>用这个方法求出的解可以在<strong>代数法</strong>中验算</p>
<h3 id="代数法">代数法</h3>
<ul>
<li>猜测解的形式</li>
<li>用数学归纳法找出使真正有效的常数</li>
</ul>
<p>如何做猜测：</p>
<ul>
<li>递归树</li>
<li>做下界和上界，然后逼近</li>
</ul>
<h3 id="Asymptotic_notation">Asymptotic notation</h3>
<p>$\Theta$:函数的上界和下界<br>$O$:函数上界<br>$\Omega$:函数下界<br>$o$<br>$\omega$</p>
<p><img src="http://i.imgur.com/v0oBeE9.png" alt="Alt text"></p>
<h3 id="阶乘">阶乘</h3>
<p>P:34</p>
<h2 id="Divide_and_Conquer">Divide and Conquer</h2>
<h3 id="$x^n$">$x^n$</h3>
<ol>
<li>普通算法$O(n)$</li>
<li>分治法递归式:$T(n) = T(n/2) + \Theta(1)$<br>复杂度:$O(lgn)$</li>
</ol>
<h3 id="Fibonacci_numbers">Fibonacci numbers</h3>
<ol>
<li>递归求和，指数级</li>
<li>线性:两个互相相加，复杂度$O(n)$,动规思想</li>
<li>利用公式:  $$ a_n = \dfrac{\sqrt{5}}{5}\cdot\left [\left( \dfrac {1 + \sqrt{5}}{2} \right)^n - \left( \dfrac {1 - \sqrt{5}}{2} \right)^n \right]$$<br><strong>但是无法实现，因为计算机中float形会丢失精度</strong></li>
<li>利用矩阵<br>$$\begin{pmatrix}F<em>{n+1} &amp; F_n\F_n &amp; F</em>{n-1}\end{pmatrix}={\begin{pmatrix} 1 &amp;1 \ 1 &amp; 0 \end{pmatrix}^n}$$<br>矩阵连乘，所以用分治法复杂度为$O(lgn)$</li>
</ol>
<h3 id="Factorial_矩阵相乘">Factorial 矩阵相乘</h3>
<ol>
<li>普通算法直接相乘$O(n^3)$</li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%88%86%E5%A1%8A%E7%9F%A9%E9%99%A3" target="_blank" rel="external">分块矩阵算法</a>相乘，然后相加<br>递归式：$T(n)=8T(n/2)+\Theta(n^2)$<br>case1复杂度:$O(n^3)$没有进步</li>
<li><a href="http://en.wikipedia.org/wiki/Strassen_algorithm" target="_blank" rel="external">Strassen algorithm</a><br>思想:相乘的代价比较大，相加是常数量，所以尽可能减少子问题，也就是减少相乘代价，增加相加的代价，但还是常数量。算法运用了7次相乘的代价，因此只有7个子问题，比之前的8个少了一个，而相加次数略微变多，但是还是常数可以忽略<br>递归式:$T(n)=7T(n/2)+\Theta(n^2)$<br>复杂度case1:$O(n^{lg7})&lt;O(n^{2.81})$<br>指数的优化有很大的作用，最优理论值为$O(n^{2.376})$</li>
</ol>
<h3 id="VLIS_layout">VLIS layout</h3>
<p>问题：一个<strong>完全二叉树</strong>铺放的面积最小，在集成电路中使用<br>假设有n个叶子节点，如何让使用的面积最小<br>高度:H(n)<br>宽度:W(n)</p>
<p>普通算法:按照树的形状进行摆放<br>面积:$H(lgn)\cdot W(n)=O(nlgn)$</p>
<p>如何将面积降低到线性，可以利用递归式<strong>反推</strong>，两个$\sqrt n$相乘可以得到线性的面积<br>递归式反推，通过主定理case1来推导如何形成$n^{1/2}$,可以猜测a=2，b=4，后面的常数小于case1中的大小，就能构造<br>将问题分成两个子问题，每个子问题是原来的4分之一。</p>
<p>算法:<a href="http://zh.wikipedia.org/wiki/H%E6%A0%91" target="_blank" rel="external">H tree</a><br>递归式:$T(n)=2T(n/4)+\Theta(1)$</p>
<h2 id="Sorting_and_Order_Statistics">Sorting and Order Statistics</h2>
<ul>
<li>內部排序：排序的資料量小，可以完全在主記憶體內進行排序</li>
<li>外部排序：排序的資料量大，無法直接在主記憶體內進行排序</li>
</ul>
<p>外排序：merge sort<br><a href="http://en.wikipedia.org/wiki/External_sorting" target="_blank" rel="external">External sorting</a></p>
<p>堆排序：如果只要求排出前x个数，只要保留x个树的堆在内存中就行，其余的叶节点都舍弃</p>
<h3 id="排序时间">排序时间</h3>
<h4 id="比较排序算法">比较排序算法</h4>
<p>定理:最坏情况，要做$\Omega(nlgn)$次比较<br>证明:P98，斯特林近似公式<br>$n!\le l\le s^h$<br>$h\ge lg(n!)$=$\Omega(nlgn)$   </p>
<p><img src="http://i.imgur.com/1CZRH4i.png" alt="Alt text"></p>
<h3 id="quicksort">quicksort</h3>
<h4 id="作用">作用</h4>
<p>分治法思想<br>原地排序<br>实践中非常有用<br>虚拟内从中缓存利用非常好</p>
<ul>
<li>Divide:partition array into 2 subarray around <strong>pivot</strong></li>
<li>conquer:recusive sort 2 subarray</li>
<li>conbine:trivial</li>
</ul>
<p>如果元素重复的比较多，性能会不好，使用Hoare</p>
<h4 id="复杂度">复杂度</h4>
<ul>
<li><p>Worst-case:already almost sorted/reverse sorted<br>$$T(n)=T(n-1)+\Theta(n)=\Theta (n^2)$$<br>like the insertion sort 等差数列</p>
</li>
<li><p>Best-case:in the middle<br>$$T(n)=2T(n/2)+\Theta(n)=\Theta(nlgn)$$</p>
</li>
<li><p>Aerage-case:lucky or unlucky<br>如果是1:10和9:10来划分，画出递归树<br>$$T(n)\le Cn \cdot \log _{10/9}{n}=\Theta(nlgn)$$<br>在luck和unluck变换，使用代换法证明就行</p>
</li>
</ul>
<h4 id="优化">优化</h4>
<p>随机化的quicksort</p>
<ul>
<li>随机化pivot</li>
<li>打乱输入顺序<br>证明:用到期望，不会，略。。。。</li>
</ul>
<p>pivot选取</p>
<ul>
<li>最左(对于已经排序的数组，复杂度太高)</li>
<li>三值取平均(会整数溢出问题)</li>
<li>随机</li>
</ul>
<p>重复元素</p>
<ul>
<li>如果数组中重复元素比较多，快排效果比较差，荷兰国旗问题</li>
<li>可以修改算法，等于pivot的算作已经排序，只要再排序大于和小于pivot的值</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">quicksort(<span class="type">A</span>, lo, hi)</div><div class="line">    <span class="keyword">if</span> lo &lt; hi</div><div class="line">        p := pivot(<span class="type">A</span>, lo, hi)</div><div class="line">        <span class="keyword">left</span>, <span class="keyword">right</span> := <span class="built_in">partition</span>(<span class="type">A</span>, p, lo, hi)  <span class="comment">// note: multiple return values</span></div><div class="line">        quicksort(<span class="type">A</span>, lo, <span class="keyword">left</span>)</div><div class="line">        quicksort(<span class="type">A</span>, <span class="keyword">right</span>, hi)</div></pre></td></tr></table></figure>

<p>资料</p>
<ul>
<li><a href="http://blog.csdn.net/nwpu_kexie/article/details/7538673" target="_blank" rel="external">怎样让快速排序更快</a></li>
<li><a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">wiki</a></li>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/02.07.md" target="_blank" rel="external">荷兰国旗问题</a></li>
</ul>
<h3 id="timsort">timsort</h3>
<h3 id="heapsort">heapsort</h3>
<p>使用最大堆<br>堆数据结构是一个数组对象，也是一棵完全二叉树<br>普遍情况下，快速排序更快。<br>堆排序常见应用：高效的优先级队列 priority queue,每次操作的时间复杂度都是$O(lgn)$<br><img src="http://i.imgur.com/3HTrr0A.png" alt="Alt text"></p>
<h4 id="MAX-HEAPIFY">MAX-HEAPIFY</h4>
<p>运行时间$O(lgn)$,保持最大堆的性质。<br>和子女比较谁大，如果小于子女，把子女中较大的提上来，依次往下</p>
<p><img src="http://i.imgur.com/JuR4pNt.png" alt="Alt text"></p>
<h4 id="BUILD-MAX-HEAP">BUILD-MAX-HEAP</h4>
<p>通过一个数组，进行最大堆的建立，从第一个不是叶子的节点开始依次调用MAX-HEAPIFY来满足最大堆的性质. 通过数学论证，这一步的复杂度一共是$O(n)$<br><img src="http://i.imgur.com/JyLZIQH.png" alt="Alt text"></p>
<h4 id="HEAPSORT">HEAPSORT</h4>
<p>首先调用BUILD-MAX-HEAP来建立一个最大堆。然后每次将第一个元素(最大)与堆中最后一个元素互换，最大的元素被排到后面，新的堆中第一项有可能不满足堆的性质，所以在此做HEAPIFY来满足</p>
<p>复杂度为$O(nlgn)$</p>
<p><img src="http://i.imgur.com/8RtgXhK.png" alt="Alt text"></p>
<h3 id="bubble_sort">bubble sort</h3>
<h3 id="insertion_sort">insertion sort</h3>
<p>running time:depend on input and input size<br>best case:already almost sorted<br>worst case:reverse sorted</p>
<p>worst case:<br>T(n)=max time to run</p>
<p>Average case:<br>T(n)=expected time<br>need assumption of statics distribution</p>
<p>Best case:bogus<br>cheat</p>
<p>O(n^2)<br>small n:fast<br>big n:slow</p>
<h3 id="mergesort">mergesort</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> n=<span class="number">1</span> done</div><div class="line">recursive <span class="built_in">sort</span></div><div class="line">	<span class="number">1</span>-n/<span class="number">2</span></div><div class="line">	n/<span class="number">2</span>-n</div><div class="line"><span class="built_in">merge</span></div></pre></td></tr></table></figure>

<p>T(n) = 2T(n/2) + O(n)</p>
<p>use recursive tree<br>tree high = lgn<br>each level = n<br>O(nlgn)</p>
<p>tips: when the element size &gt; 30 ,the merge sort is better than insertion sort</p>
<h3 id="selection_sort">selection sort</h3>
<h3 id="shell_sort">shell sort</h3>
<h3 id="bucket_sort">bucket sort</h3>
<p>当输入符合均匀分布时，就可以得到线性期望时间<br>复杂度:$O(n+k)$<br>空间复杂度非常高<br><img src="http://i.imgur.com/SlYm6SF.png" alt="Alt text"></p>
<p><a href="http://hxraid.iteye.com/blog/647759" target="_blank" rel="external">桶排序</a></p>
<h3 id="counting_sort">counting sort</h3>
<p>假设n个输入元素中的每一个都介于0到k之间的整数,此处k为某个整数，总时间复杂度$\Theta(n+k)$，当$k=O(n)$时，计数排序为$\Theta(n)$<br>计算每一个值出现的次数，放入一个数组中，最后反向遍历数组进行排序<br>性质:稳定排序，相同值的相对次序不会改变</p>
<p><img src="http://i.imgur.com/X0yGjXa.png" alt="Alt text"></p>
<h3 id="radix_sort">radix sort</h3>
<p>利用counting sort的稳定排序来对数的最后一位开始进行排序<br><img src="http://i.imgur.com/c7qIh9X.png" alt="Alt text"></p>
<p>定理：Given n d -digit numbers in which each digit can take on up to k possible values, RADIX-SORT correctly sorts these numbers in ‚.d.n C k// time if the stable sort it uses takes ‚.n C k/ time.</p>
<p>定理：Given n b-bit numbers and any positive integer r 􏰎 b, RADIX-SORT correctly sorts these numbers in ‚..b=r/.n C 2r // time if the stable sort it uses takes ‚.n C k/ time for inputs in the range 0 to k.</p>
<h3 id="Medians_and_Order_Statistics">Medians and Order Statistics</h3>
<p>input:输入包含n个不同数的集合A和一个数i<br>output:元素x，恰好大于A中其他$i-1$个元素</p>
<h4 id="Minimum_and_maximum">Minimum and maximum</h4>
<p>单纯最大值或者最小值:$n-1$次比较</p>
<p>同时最大或者最小:$3\lfloor n/2 \rfloor$次比较<br>先将一对输入元素互相比较，然后较小者与当前最小值比较，较大者与当前最大值比较，因此每两个元素要3次比较</p>
<h4 id="Selection_in_expected_linear_time">Selection in expected linear time</h4>
<p>利用快速排序，但是只做一边的递归，而不做另外一边的递归<br>平均复杂度:$\Theta(n)$<br>最坏复杂度:$\Theta(n^2)$</p>
<p><img src="http://i.imgur.com/R4HUKYj.png" alt="Alt text"></p>
<h4 id="Selection_in_worst-case_linear_time">Selection in worst-case linear time</h4>
<p>可以当情况最坏时，还是保证线性的时间复杂度，但是其中的线性的常量会非常高，所以一般不可取，理论上实现了，一般还是用普通的选择算法<br>主要思想:在快排中让子问题规模小于1，这样就有线性的时间复杂度了</p>
<p><img src="http://i.imgur.com/xKTTQqN.png" alt="Alt text"><br><img src="http://i.imgur.com/luCxdDe.png" alt="Alt text"><br><img src="http://i.imgur.com/iFnmpkQ.png" alt="Alt text">                                                                                                                                                                                                                                                                                                                                       </p>
<h2 id="Hash_Tables">Hash Tables</h2>
<h3 id="Direct-address_tables">Direct-address tables</h3>
<p>当关键字全域比较小时，直接寻址简单有效<br><img src="./1427484381325.png" alt="Alt text"></p>
<p>U很大时，需要的容量太大，但是实际用到的缺比较小</p>
<h3 id="Hash_Tables-1">Hash Tables</h3>
<p>直接寻址：k个关键字元素存放在槽 k<br>散列：通过哈希函数存放在[0.。m-1]的槽上<br>通过哈希把需要的下标从 U降低为 m 了</p>
<p><img src="http://i.imgur.com/ZVWEetA.png" alt="Alt text"></p>
<p>但是还要处理碰撞问题，两个不同的 key 哈希一个相当的哈希值，就要解决</p>
<p>连接法：<br> <img src="http://i.imgur.com/8WwAR0F.png" alt="Alt text"></p>
<p> n 个元素，m 个槽，装载因子$\alpha$为 n/m，即一个链中平均存储的元素数<br> 最坏情况：$\Theta (n)$<br>简单一致散列（simple uniform hashing）：假定任何元素散列到 m 个槽中每一个的可能性是相同的，且与其他元素被散列到什么位置是独立无关的</p>
<p>定理：对于一个用链接技术来解决碰撞的散列表，在简单一致散列的假设下，一次不成功查找的期望时间为$\Theta(1+\alpha )$<br>定理：对于一个用链接技术来解决碰撞的散列表，在简单一致散列的假设下，平均情况下一次成功的查找需要$\Theta(1+\alpha )$<br>于是，一次查找的时间为$\Theta(1+\alpha )$<br>结论：如果散列表中的槽数至少与表中的元素成正比，所有的字典操作都只要$O(1)$来完成</p>
<h3 id="Hash_function">Hash function</h3>
<p>好的散列函数满足简单一致散列的假设<br>把关键字解释为自然数</p>
<p>除法散列法：<br>$h(k)=k\ mod\ m$<br>m 不应该是2的幂<br>m 常常是与2的整数幂不太接近的质数<br>除法在计算机中操作循环太多</p>
<p>乘法散列法:<br>$h(k)=\lfloor m(kA\ mod\ 1)\rfloor$<br>m 一般取2的某个幂($m=2^p$，p 为某个整数)<br>计算机字长为 w 位<br><img src="http://i.imgur.com/sLsIli8.png" alt="Alt text"></p>
<p>$A\approx (\sqrt5-1)/2=0.618\ 033\ 988\ 7…$</p>
<h3 id="Open_addressing">Open addressing</h3>
<p>把所有元素都存放在散列表中，不用额外的指针节约空间，查找元素时，要检查所有的表项，知道找到所需的元素，或发现元素不在表内。这种方法散列表可能被填满，然后不能插入新的元素</p>
<p>装载因子$\alpha$不超过1</p>
<p>探查寻列<br><img src="http://i.imgur.com/pMMiYLK.png" alt="Alt text"></p>
<p>开放寻址中，对于散列元素的删除很困难。当使用特殊的值 DELETED 时，查找时间就不再依赖装载因子$\alpha$了，所以在删除关键字的应用中，往往采用连接法来解决碰撞</p>
<p>三种技术</p>
<ol>
<li>线性探查</li>
</ol>
<ul>
<li>每次探查哈希之后的下一个</li>
<li>简单快速</li>
<li>有集群问题，当连续的槽被填满时，查找时间会增加</li>
</ul>
<ol>
<li>二次探查</li>
</ol>
<ul>
<li>有二次集群问题</li>
</ul>
<ol>
<li>双重散列</li>
</ol>
<ul>
<li>是开放寻址方的最好方式</li>
<li>$h(k,i)=(h_1(k)+ih_2(k))mod\ m$</li>
<li>两个哈希函数，每次增加第二个哈希函数的值</li>
<li>为了能查找整个散列表，$h_2(k)$要与表的大小 m 互质</li>
<li>双重散列用了$\Theta(m^2)$中探查序列，线性探查或者二次探查用了$\Theta(m)$次，所以后者更好</li>
</ul>
<p>分析<br>定理：给定一个装载因子为$\alpha =n/m&lt;1$的开放寻址散列表，再一次不成功的查找中，期望的探查数至多为$1/(1-\alpha)$<br>推论：给定一个装载因子为$\alpha =n/m&lt;1$的开放寻址散列表，再插入操作，需要为$1/(1-\alpha)$探查<br>定理：给定一个装载因子为$\alpha =n/m&lt;1$的开放寻址散列表，再一次成功的查找中，探查数为<br>$$\dfrac {1}{\alpha}In\dfrac {1}{1-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \alpha}$$</p>
<h2 id="Tree">Tree</h2>
<h3 id="Binary_Search_Trees">Binary Search Trees</h3>
<p>中序遍历：按顺序输出，复杂度$\Theta (n)$<br>定理：对于树高 h 的二叉查找树，动态集合操作 search,min,max,successor,predecessor,insert,delete 运行时间为$O(h)$<br>定理：一棵在 n 个关键字上随机构造二叉查找树的期望高度为$O(lgn)$</p>
<h3 id="Red-Black_Trees">Red-Black Trees</h3>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8" target="_blank" rel="external">尾递归</a>:栈优化</li>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="external">july红黑树</a></li>
<li><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" target="_blank" rel="external">动画</a><br>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。<br>通过对任何一条从根到叶子的路径上各个结点着色方式的限制，<code>红黑树确保没有一条路径会比其他路径长出俩倍</code>，因而是接近平衡的。<br>红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为<code>O(lgn)</code>。</li>
</ul>
<h4 id="Properties_of_red-black_trees">Properties of red-black trees</h4>
<ul>
<li>每个结点要么是红的要么是黑的。  </li>
<li>根结点是黑的。  </li>
<li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  </li>
<li>如果一个结点是红的，那么它的两个儿子都是黑的。  </li>
<li>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 </li>
</ul>
<h4 id="Insert">Insert</h4>
<ul>
<li>如果插入的是根结点，因为原树是空树，此情况只会违反性质2，所以直接把此结点涂为黑色。</li>
<li>如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时也是什么也不做。</li>
</ul>
<p>但当遇到下述3种情况时：</p>
<ul>
<li>插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色</li>
<li>插入修复情况2：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子</li>
<li>插入修复情况3：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子</li>
</ul>
<h4 id="Delete">Delete</h4>
<blockquote>
<p>在删除结点后，原红黑树的性质可能被改变，如果删除的是红色结点，那么原红黑树的性质依旧保持，此时不用做修正操作，如果删除的结点是黑色结点，原红黑树的性质可能会被改变，我们要对其做修正操作。那么哪些树的性质会发生变化呢，如果删除结点不是树唯一结点，那么删除结点的那一个支的到各叶结点的黑色结点数会发生变化，此时性质5被破坏。如果被删结点的唯一非空子结点是红色，而被删结点的父结点也是红色，那么性质4被破坏。如果被删结点是根结点，而它的唯一非空子结点是红色，则删除后新根结点将变成红色，违背性质2。</p>
</blockquote>
<p>六种情况：<br>如果是以下情况，恢复比较简单：</p>
<ul>
<li>当前结点是红+黑色<br>解法，直接把当前结点染成黑色，结束此时红黑树性质全部恢复。</li>
<li><p>当前结点是黑+黑且是根结点， 解法：什么都不做，结束。<br>但如果是以下情况呢？：</p>
</li>
<li><p>删除修复情况1：当前结点是黑+黑且兄弟结点为红色(此时父结点和兄弟结点的子结点分为黑)</p>
</li>
<li>删除修复情况2：当前结点是黑加黑且兄弟是黑色且兄弟结点的两个子结点全为黑色</li>
<li>删除修复情况3：当前结点颜色是黑+黑，兄弟结点是黑色，兄弟的左子是红色，右子是黑色</li>
<li>删除修复情况4：当前结点颜色是黑-黑色，它的兄弟结点是黑色，但是兄弟结点的右子是红色，兄弟结点左子的颜色任意</li>
</ul>
<h3 id="Augmenting_Data_Structures">Augmenting Data Structures</h3>
<p>在许多应用中，要求数据结构要有所创新，但是很少创造全新的数据结构，所以可以对已有的数据结构进行扩张</p>
<h4 id="RB_Tree：Dynamic_order_statistics">RB Tree：Dynamic order statistics</h4>
<p>第九章中，使用快排能再 O(n)时间内找到第 i 个顺序统计量<br>但是用红黑树可以在O(lgn)内找到，一个元素的排序也能再 O(lgn)内找到</p>
<p>扩展红黑树，增加一个 seiz 域，表明这个节点 子树个数，包括自己<br><img src="http://i.imgur.com/ldyxvwe.png" alt="Alt text"></p>
<ul>
<li>检索具有给定排序的元素，O(lgn)</li>
<li>确定一个元素的 rank，中序遍历思想 O(lgn)</li>
<li>对子树规模的维护，每次维护都是O(1) </li>
</ul>
<h4 id="How_to_augment_a_data_structure">How to augment a data structure</h4>
<p>四个步骤</p>
<ol>
<li>选择基础的数据结构</li>
<li>确定要在数据结构中添加哪些信息</li>
<li>验证可用基础数据结构上的基础修改操作来维护这些新添加的信息</li>
<li>设计新的操作</li>
</ol>
<p>红黑树：</p>
<ul>
<li>提供 size 域</li>
<li>插入和删除</li>
<li>新操作 OS-SELECT和 OS-RANK</li>
</ul>
<h4 id="Interval_trees">Interval trees</h4>
<p>一个红黑数上存储的是一个区间，以最小额时间来排序，增加一个 max，显示子树中端的最大值<br><img src="http://i.imgur.com/LQ7gOLz.png" alt="Alt text"></p>
<p>步骤</p>
<ol>
<li>基础数据结构为红黑树</li>
<li>附加信息 max</li>
<li>对信息维护，插入和删除操作</li>
<li>添加新的操作，interval-search，找出 T中覆盖区间 i 的哪个节点，如果不存在就返回 nil</li>
</ol>
<h3 id="B_Tree">B Tree</h3>
<h4 id="Properties">Properties</h4>
<p>降低磁盘I/O操作次数，数据库中经常使用，和红黑树类似<br>与红黑树不同：B树的结点有很多子女<br>B树算法在主存中只要一定量的页数，所以主存的大小不限制可被处理的B树的大小<br>一个结点的大小通常相当于一个完整的磁盘页，所以，一个B树结点可以拥有的子女数就有磁盘页的大小决定<br>选取一个大的分支因子，可以大大降低树高，降低了磁盘的存取次数</p>
<h4 id="Definition">Definition</h4>
<p><img src="http://i.imgur.com/yJSAYoc.png" alt="Alt text"><br><img src="http://i.imgur.com/oRCERAb.png" alt="Alt text"></p>
<p>树高：<img src="http://i.imgur.com/61lq7iC.png" alt="Alt text"><br>和红黑树比较：高度都是(lgn)，但是B树要少lgt的因子</p>
<h4 id="Search">Search</h4>
<p>和二叉搜索树差不多<br>树高不一样更短，但是一个结点内的搜索长度更长</p>
<h4 id="Insert-1">Insert</h4>
<p>要分裂来增加树高<br>碰见满的就要分裂</p>
<h4 id="Delete-1">Delete</h4>
<p>对结点x递归调用B-TREE-DELETE后，x的关键个数都至少等于最小度数t，而不是t-1<br>3个类别，6种情况书中 P274</p>
<h3 id="skip_list">skip list</h3>
<p>在一个排序的链表中，做一次的搜索复杂度是 O(n),因为要一次一次的进行搜索，但是用了跳跃表后可以将删除，插入，搜索做到 log(n),</p>
<p>创建多个辅助的表，每一个表示下面一层表的一半<br><img src="http://i.imgur.com/iqhvt3a.png" alt="Alt text"><br>每一次插入就有50%几率往上一层添加元素，这样能保持跳跃表</p>
<p><a href="http://blog.csdn.net/zy825316/article/details/22600003" target="_blank" rel="external">跳跃表资料</a></p>
<h2 id="Dynamic_Programming">Dynamic Programming</h2>
<h3 id="装配线问题">装配线问题</h3>
<p>比较简单，一共两个子问题，</p>
<h3 id="Matrix-chain_multiplication">Matrix-chain multiplication</h3>
<p>矩阵相乘中不同的排列组合得出的乘法量不同<br><a href="https://github.com/liulin2012/algorithm/blob/master/15/matrix.cpp" target="_blank" rel="external">代码</a></p>
<h3 id="LCS">LCS</h3>
<h3 id="Four_steps">Four steps</h3>
<ul>
<li>描述最优解的结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方式计算最优解的值</li>
<li>由计算的结果构造一个最优解</li>
</ul>
<p>先自顶向下递归定义最优解，然后自底向上来寻找这个最优解。<br>第四步如果不需要路径可以省略。需要额外空间存储。</p>
<h3 id="Elements_of_dynamic_programming">Elements of dynamic programming</h3>
<ul>
<li>最优子结构<br>当一个问题拥有最优子结构，就提示可以用DP<br>寻找最有子结构：</li>
</ul>
<ol>
<li>问题的一个解可以是做一个选择。做这种选择会的到一个或者多个有待解决的子问题</li>
<li>假设对一个给定的问题，已知的时一个可以导致最优解的选择，不必关心如何确定这个选择，假定是已知 。</li>
<li>选择后，确定哪些子问题会随之发生。</li>
<li>利用剪贴技术证明<br>最优子结构</li>
<li>有多少子问题被使用</li>
<li>在决定一个最优解时又多少选择</li>
<li>时间依赖于两个的乘积</li>
</ol>
<ul>
<li>重叠子问题<br>原本的递归解有很多重复的子问题，而不是产生新的子问题</li>
<li>备忘录（递归）<br>重复的子问题用备忘录来记录</li>
</ul>
<h3 id="Greedy">Greedy</h3>
<p>动态规划的一种，要证明递归的任一阶段，最优的选择总是贪心选择，所以贪心选择是安全的，通过贪心选择，子问题（除了一个）都为空</p>
<p>例子：0-1背包和部分背包<br>赫夫曼编码：取出词频最小的组合<br>使用最小堆时间复杂度O(nlgn)</p>
<h3 id="Amortized_Analysis">Amortized Analysis</h3>
<p>执行一系列数据结构操作所需要的时间是通过对执行的所有操作的平均而得出的。<br>即使单一的操作有较大代价，平均代价还是很小的</p>
<p>动态增长数组<br>单一操作：增加一个元素，增加一倍长<br>平均：增加一个元素，但是不用增加原数组一倍长</p>
<ul>
<li>聚集分析(aggregate analysis)<br>对于所有 n，由 n 个操作所构成的序列的总时间在最坏情况下为 $T(n)$，因此这个操作的平均代价为$T(n)/n$</li>
<li>记账方法<br>赋予不同的操作不同的费用，某些操作的费用比他们的实际代价或多或少</li>
<li>势能方法(potential method)</li>
</ul>
<p>MTF 自组织表，在链表中，总是把刚被访问的元素放到链表头上<br><a href="http://blog.csdn.net/onyheart/article/details/16331219" target="_blank" rel="external">竞争性分析</a></p>
<h2 id="Fibonacci_number">Fibonacci number</h2>
<p><img src="http://i.imgur.com/YJV8kYb.png" alt="Alt text"></p>
<p>用两个值互相加就行。<br>O(1) 空间复杂度</p>
<p>斐波那契数列:</p>
<ol>
<li>递归求和，指数级</li>
<li>线性:两个互相相加，复杂度$O(n)$</li>
<li>利用公式:  $$ a_n = \dfrac{\sqrt{5}}{5}\cdot\left [\left( \dfrac {1 + \sqrt{5}}{2} \right)^n - \left( \dfrac {1 - \sqrt{5}}{2} \right)^n \right]$$<br><strong>但是无法实现，因为计算机中float形会丢失精度</strong></li>
<li>利用矩阵<br>$$\begin{pmatrix}F<em>{n+1} &amp; F_n\F_n &amp; F</em>{n-1}\end{pmatrix}={\begin{pmatrix} 1 &amp;1 \ 1 &amp; 0 \end{pmatrix}^n}$$<br>矩阵连乘，所以用分治法复杂度为$O(lgn)$</li>
</ol>
<h3 id="Fibonacci_heap">Fibonacci heap</h3>
<p>很好的支持 union 操作，如果不需要 union，普通的二叉堆的性能就很好。<br>斐波那契堆的时间是平摊时间，不是最坏时间。<br><img src="http://i.imgur.com/kP1zC0U.png" alt=""></p>
<p>所有的操作都延后到 EXTRACE-MIN 的时候进行，非常复杂。</p>
<h2 id="Data_Structures_for_Disjoint_Sets">Data Structures for Disjoint Sets</h2>
<p>两个重要操作：<br>找出给定的元素所属的集合<br>合并</p>
<p><img src="http://i.imgur.com/HNRUJA2.png" alt=""></p>
<h3 id="Linked-list_representation_of_disjoint_sets">Linked-list representation of disjoint sets</h3>
<p>每个集合都用一个链表表示，每个链表的第一个对象作为所在集合的代表。链表中的每一个对象都包含一个集合成员，一个指向包含下一个集合成员的对象的指针，一级指向代表的指针。</p>
<p><img src="http://i.imgur.com/39X3bNU.png" alt=""></p>
<p>用加权的方法<br>定理：利用不相交集合的链表表示和加权合并启发式，一个包含 m 个 MAKE-SET，UNION 和 FIND-SET 操作，哪个 MAKE-SET 操作，的序列 需要$O(m+nlgn)$</p>
<h3 id="Disjoint-set_forests">Disjoint-set forests</h3>
<p>目前已知最快的不相交集合的数据结构<br>每棵树都代表一个集合，每棵树的根包含了代表，并且它是自己的父节点</p>
<p><img src="http://i.imgur.com/aDkYAUI.png" alt=""></p>
<p>MAKE-SET：创建一个结点的树<br>FIND-SET：沿着父节点一直找到树根<br>UNION：让一棵树的树根指向另一棵树的根</p>
<p>union by rank:包含较少结点的树的根指向包含较多结点的树的根<br>path compression:FIND-SET 操作中让查找路径上的每一个结点都直接指向根节点。路径压缩不改变 rank<br><img src="http://i.imgur.com/Yidqkow.png" alt=""></p>
<p>UNION 时，看 rank 是不是相等，相等就加1，不相等就用rank 大的作为父节点，rank 不变。</p>
<p>最坏情况$O(ma(n))$，$a(n)$增长非常缓慢 &lt;=4    </p>
<h2 id="Graph">Graph</h2>
<p>有向图G是一对(V,E)<br>无向图不允许自身环</p>
<p>无向图度<br>有相图：出度+入度</p>
<p>简单路径：如果路径上各顶点不重复，那就是简单路径<br>回路和简单回路</p>
<p>无向图：连通图，连通分支<br>有相图：互相可达，强连通图，强连通分支</p>
<h3 id="Representations_of_graphs">Representations of graphs</h3>
<p>邻接表：稀疏<br>$Storage:\theta (V+E)$</p>
<p>邻接矩阵：稠密<br>$Storage:\theta (v^2)$</p>
<p><img src="http://i.imgur.com/Eoq0X5k.png" alt=""></p>
<h3 id="BFS">BFS</h3>
<p>典型算法，prim最小生成树，Dijkstra单元最短路径</p>
<p>给定图G和一个特定的源项点s的情况下，广度优先搜索系统地搜索G中的边，以期发现可从s到达 所有顶点，并计算s到所有顶点可达顶点之间的距离。该算法同时生成一棵树，包括所有s的可达顶点的广度优先树。<br>该算法对有向图和无向图都有用。<br>无向图例子：prim<br>有向图例子：Dijkstra</p>
<p>广度优先：始终是将已发现和未发现顶点之间的边界，沿其广度方向向外扩展。<br>广度优先树可能会有所不同，但是计算出来的距离一定是相同的</p>
<p><img src="http://i.imgur.com/h6dGhtH.png" alt=""></p>
<p>时间复杂度使用聚集分析，每个顶点入队列和进队列各一次，所以是$O(V)$，每一个邻接表都在顶点出队列时被扫描，所以是$O(E)$.<br>所以加上初始化，BFS总的运行时间为$O(V+E)$<br>tips，这和计算Dijkstra算法有点类似，但是Dijkstra用的时优先权队列，所以复杂度更高。</p>
<p>和Dijkstra的区别</p>
<ol>
<li>不是优先权队列，而是普通的FIFO队列，所以复杂度更低</li>
<li>relax的过程是+1，而不是加权。</li>
</ol>
<p>广度优先树：<br>BFS过程中的$\pi$来构建<br><img src="http://i.imgur.com/G7nvTGo.png" alt=""></p>
<h3 id="Single-Source_Shortest_Paths">Single-Source Shortest Paths</h3>
<p>边的权值可以代表各种，路径，时间等</p>
<p>单元最短路径的变种</p>
<ul>
<li>单终点最短路径问题：找出每个顶点v到指定终点t的最短路径。把图中每条边反向，就是单源最短路径了</li>
<li>单对顶点最短路径问题：给定u和v一条最短路径。还是利用单源最短路径，没有更好的算法</li>
<li>每对顶点间的最短路径问题：不必对每个顶点都做单源最短路径</li>
</ul>
<p>最优子结构：<br>一条两顶点间的最短路径包含路径上其他的最短路径，这事动态规划和贪心的标志<br>Dijkstra是贪心，Floyd-Warashall是动态规划</p>
<p>定理：最短路径的子路径也是最短路径</p>
<p>负权值边：<br>如果存在负权值<strong>回路</strong>，那就没有最短路径</p>
<p>Dijkstra算法假定所有的边都是非负权值。<br>Bellman-Ford允许负权值，只要不存在负权回路。存在的话，算法也可以检测并报告</p>
<p>最短路径的表示和BFS一样，但是用的不是边而是权值表示。</p>
<p>松弛技术：描述最短路径上权值的上界，松弛之后会让权值变小，最后的权值就是最短路径的权值<br>Dijkstra以及有向无回路的最短路径算法中，对每一条边执行一次松弛操作<br>Bellman-Ford执行多次<br><img src="http://i.imgur.com/M2QuP5L.png" alt=""><br><img src="http://i.imgur.com/4R784tj.png" alt=""></p>
<h3 id="Dijkstra">Dijkstra</h3>
<p>一种BFS<br>要求权值非负<br>用到最小优先权队列，初始化为所有顶点，每次取出一个顶点然后更新别的顶点权值。和prim还有BFS一样的思想<br>取出顶点为EXTRACT-MIN，更新别的顶点权值为DECRASE-KEY。这和数据结构的使用还有复杂度有关<br><img src="http://i.imgur.com/b5hXibY.png" alt=""></p>
<p>算法复杂度分析：<br>一共需要V次EXTRACT-MIN和INSERT。最多E次DECRASE-KEY。Fib heap就是利用了这个性质，因为DECRASE-KEY的次数一般远大于EXTRACT-MIN。<br>数组：$O(V^2)$<br>二叉最小堆：$O((V+E)lgV)$<br>斐波那契堆：$O(E+VlgV)$</p>
<h3 id="DFS">DFS</h3>
<p>DFS产生的先辈子图可以由几棵树组成。BFS就一棵树<br>形成的叫做深度优先森林<br>还为每个顶点加盖时间戳。每个顶点有两个时间戳，开始和结束的</p>
<p><img src="http://i.imgur.com/W55oMAF.png" alt=""></p>
<p>时间复杂度：$\theta (V+E)$</p>
<p>性质</p>
<ul>
<li>先辈子图形成的森林，准确反映了递归调用的顺序</li>
<li>括号定理</li>
<li>后裔区间的嵌套</li>
<li>白色路径定理</li>
</ul>
<p><img src="http://i.imgur.com/LgHqClm.png" alt=""></p>
<p>边的分类：</p>
<ul>
<li>树边：白色</li>
<li>反向边：灰色</li>
<li>正向边：黑色</li>
<li>交叉边：黑色</li>
</ul>
<p>无向图中，只有树边和反向边</p>
<h3 id="Topological_sort">Topological sort</h3>
<p>dag：有向无回路图<br>可以说明事物的发展顺序</p>
<p><img src="http://i.imgur.com/UyHJiY8.png" alt=""><br>按照<strong>完成的时间</strong>进行<strong>降序</strong>排序<br>定理：一个有向图G是无回路的，当且仅当G进行深度优先搜索时没有得到反向边</p>
<p><a href="http://blog.csdn.net/dm_vincent/article/details/7714519" target="_blank" rel="external">拓扑排序的原理及其实现</a><br><a href="http://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="external">wiki</a></p>
<h3 id="Single-source_shortest_paths_in_DAG">Single-source shortest paths in DAG</h3>
<p>先对图进行拓扑排序，然后计算最短路径，复杂度线性$\theta (V+E)$<br><img src="http://i.imgur.com/i7Ny2ZR.png" alt=""></p>
<h3 id="强连通分支">强连通分支</h3>
<p>把一个有向图分解为各强连通分支。<br>分解之后，算法在每一个强连通分支上独立运行<br>最后根据各个分支之间的关系，把所有的解组合起来。</p>
<p>G和G的转制有同样的强连通分支<br><img src="http://i.imgur.com/gouGGoe.png" alt=""><br><img src="http://i.imgur.com/MTKrEiI.png" alt=""><br>第一次DFS之后，按照<strong>完成</strong>时间降序进行排序，转制G，然后执行DFS。其实就是通过一次拓扑排序的顺序来进行DFS。但是转制之后G，如果不是连通的话是无法到达，但是如果是强连通的话，还是依然可以到达。这样就可以形成不同的强连通分支。模拟拓扑排序来理解算法。</p>
<h3 id="Minimum_Spanning_Trees">Minimum Spanning Trees</h3>
<p>生成树：无向图中，T无回路且连接所有的顶点，必然是一棵树。<br><img src="http://i.imgur.com/frXembU.png" alt=""></p>
<p>循环不变式：<br><img src="http://i.imgur.com/ntBSh87.png" alt=""></p>
<p>一个 MST 删去一条边，形成的两个子树还是 MST。<br>两个cut 之间选能保证无回路。<br>选出来的局部最优也是全局最优可以证明23.1<br>推论23.2为后面的算法用到<br>P345</p>
<p>两种实现的算法<br>In Kruskal’s algorithm, the set A is a forest whose vertices are all those of the given graph. The safe edge added to A is always a least-weight edge in the graph that connects two distinct components.<br>In Prim’s algorithm, the set A forms a single tree. The safe edge added to A is always a least-weight edge connecting the tree to a vertex not in the tree.</p>
<h4 id="Kruskal">Kruskal</h4>
<p>利用不相交森林，每一个顶点起初都是一个森林，边按照权值来进行非降序排列。<br>每次取出一个权值最小的边，看两个顶点是否为在一个森林中，不在的话就union在一起。<br>不相交森林的实现在之前的章节有，利用了rank和压缩路径来进行，能将算法的复杂度降低。<br>复杂度：$O(ElgV)$<br><img src="http://i.imgur.com/8AK4lcF.png" alt=""></p>
<h4 id="Prim">Prim</h4>
<p>每一步，把连接了树A和GA 中的某孤立顶点的轻边加入到树A<br>有效实现prim算法的关键是设法容易地选择一条新的边，将其添加到由Ade边所形成的树中。<br>不在树中的所有顶点都放在一个基于key域的最小优先权队列Q中。<br>复杂度取决于使用的数据结构<br>二叉堆:$O(ElgV)$<br>斐波那契堆:$O(E+VlgV)$<br><img src="http://i.imgur.com/O0t98jp.png" alt="">·</p>
<h3 id="Bellman-Ford">Bellman-Ford</h3>
<p>可以有负值<br>会报告负值回路<br><img src="http://i.imgur.com/sflETMi.png" alt=""><br>2到4行算权值<br>5到7行判断有没有负权回路<br>操作复杂度：$O(VE)$</p>
<p>检验边时可以以任意顺序，这样就不需要知道全局的情况。分布式系统中只要和相邻的端尿性交互信息就行，比如说网络中的寻找最短路径，每个机器不需要知道所有机器和路径的情况，只要知道最近的就行。但是网络中要解决路径权值增加或者减少的问题，因为网络会堵塞或者空闲</p>
<h4 id="Difference_constraints_and_shortest_paths">Difference constraints and shortest paths</h4>
<p>线性规划中，要寻找最大值，但是有时候只想知道可行解，或者线性规划有一些特殊情况，可以达到多项式复杂度的解法。</p>
<p>差分约束：线性规划A的每一行包含一个1和个-1，所有其他元素为0.找出满足要求的解或者知道无可行解<br>相似处有两点：</p>
<ul>
<li>差分约束条件和最短路径中的松弛是一个道理</li>
<li>约束图中有负权回路，差分约束无解<br><img src="http://i.imgur.com/ImDaow7.png" alt=""><br><img src="http://i.imgur.com/MnZW1Rp.png" alt=""></li>
</ul>
<h3 id="All-Pairs_Shortest_Paths">All-Pairs Shortest Paths</h3>
<p>对于无权边，用V次BFS。$O(V^2+VE)$<br>对于没有负权值的有向图，用V次Dijkstra。$O(VE+V^2lgv)$<br>对于有负权值的，可以进行改进，V次Bellman-Ford太费时间。</p>
<h4 id="Shortest_paths_and_matrix_multiplication">Shortest paths and matrix multiplication</h4>
<p>复杂度：$\theta (n^3lgn)$<br>利用矩阵的n次方可以分治法来进行相乘。因为等式满足结合律</p>
<h4 id="Floyd-Warshall">Floyd-Warshall</h4>
<p>复杂度：$\theta (V^3)$<br>利用另一种DP思想来进行求解<br><img src="http://i.imgur.com/j4gW6FJ.png" alt=""></p>
<h4 id="Johnson">Johnson</h4>
<p>复杂度：$O(V^2 lgV + VE)$<br>结合了Dijkstra和Bellman-ford，复杂度和用Dijkstra一样。<br>主要思想是，利用重新赋值权值，而且不会改变最短路径的引力<br>这样将权值进行修改之后没有负数权值，这样就可以用Dijkstra,所以复杂度和V次Dijkstra一样<br><img src="http://i.imgur.com/a7Bqjwg.png" alt=""></p>
<p>先用Bellman-Ford，然后通过计算出来的结果来重赋权值得到非负权值，执行V次Dijkstra来获得最后的结果</p>
<h3 id="Maximum_Flow">Maximum Flow</h3>
<p>定义：比如物流问题，每一个城市都有出货 能力，如何按照一定的速度生产产品能和运输的时间匹配上,最后的目的是让运输量最大。源点和汇点之间找出之间的最大流<br>流的定义：进入运输网络中间某个城市的速度，必须等于它们离开该城市的速度，否则会堆积，这就是流守恒<br>具有多个源点和多个汇点的网络和单源点，单汇点是一样的<br><img src="http://i.imgur.com/B9rzBno.png" alt=""></p>
<h4 id="Ford-Fulkerson">Ford-Fulkerson</h4>
<p>总思想：起初都为0，每次迭代，寻找一条<strong>增广路径</strong>。增加路径可以看做是源点s到汇点t之间的一条路景，沿着这个路径可以压入更多的流。反复这个过程直到不存在增广路径了，说明压不进更多的流了。最大流最小割定理说明算法结束时，能计算出最大流。</p>
<p>残留网络：给定一个网络和一个流，残留网络由可以容纳更多网络流的边组成<br><img src="http://i.imgur.com/aEoaTtI.png" alt=""><br>阴影是增广路径</p>
<p>增广路经：给定网络Ghetto流f，增广路径p是残留网络G中从s到t的一条简单路径</p>
<p>证明一个流是最大流，当且仅当它的残留网络不包含增广路径。<br><img src="http://i.imgur.com/2IAO8zo.png" alt="Imgur"><br>初始化为0，每次找一条增光路经，然后更新。直至找不到增广路径。<br>例子书上有</p>
<p>如何找增广路径很重要，选不好算法可能不会停止。如果采用BFS来选择增广u，算法的运行时间是多项式复杂度的。<br>复杂度分析：while循环最多执行$|f<em>|$次，因为每次迭代，流的值最少增加1.$|f</em>|$是算法找出的最大流。<br>所以复杂度为$O(E|f<em>|)$<br>$|f</em>|$小时算法速度还不错，如果很大时，比如特例情况<br><img src="http://i.imgur.com/Evmfu9F.png" alt="Imgur"></p>
<p>第四行用广度优先搜索来对增广路径进行计算。能够改进方法复杂度。这种实现叫做Edmonds-Karp算法<br>复杂度：$O(VE^2)$</p>
<h4 id="Maximum_bipartite_matching">Maximum bipartite matching</h4>
<p>定义：无向图中，左边 右边的匹配要最多<br>对于一个无向二分图。建立流网络，对它进行Ford-Fulkerson方法，根据求得的具有整数值的最大流f，可以直接获得最大的匹配M<br><img src="http://i.imgur.com/gVvg6Rb.png" alt="Imgur"></p>
<h2 id="Matrix_Operations">Matrix Operations</h2>
<p>矩阵的基本操作加减乘，逆矩阵，解线性方程式<br>矩阵的操作具有数值稳定性，因为大了之后如果不稳定float型会不准。<br>向量vector就是数字的一维矩阵</p>
<p>strassen乘法算法的复杂度从$O(n^3)$到了$O(n^{lg7})$<br>最好的已知是$O(n^{2.376})$</p>
<h3 id="解线性方程式">解线性方程式</h3>
<p>最简单的方法就是<a href="https://www.wikiwand.com/en/Gaussian_elimination" target="_blank" rel="external">高斯消元</a>，但是只能做一次，所以基本的方法是LUP分解，数值稳定而且速度快，算出来之后可以做任何Ax=b</p>
<p>L是单位下三角矩阵<br>U是上三角矩阵<br>P是一个置换矩阵</p>
<p>优点就是当A进行了LU分解之后就可以通过公式来求解方程：正向替换和逆向替换<br><img src="http://i.imgur.com/KVjWUDH.png" alt=""><br><img src="http://i.imgur.com/DMoNCt8.png" alt=""></p>
<p>如何进行LUP分解，用到了高斯消元，之所以要用到P事为了选取更大的主元，这样就不会有精度问题，也不能让主元为0，full pivoting是row和column都换，partial是换row。<br>所以主要是进行lu分解<br><img src="http://i.imgur.com/GPAzACk.png" alt=""></p>
<p>分解完了之后就能通过之前的正向替换和反向替换来求解<strong>任何</strong>Ax=b，包括求逆矩阵<br>求逆矩阵就是每次都求逆矩阵中的一列</p>
<p>复杂度分析：<br>LUP分解是：$O(n^3)$<br>分解完之后任何线性方程式都是:$O(n^2)$</p>
<p>对于特殊矩阵比如三对角矩阵tridiagonal matrix所有操作都是$n$</p>
<h2 id="Classic_Topics">Classic Topics</h2>
<h3 id="Editor_distance">Editor distance</h3>
<p><a href="http://wilbeibi.com/2015/05/2015-05-09-K_edit_distances/" target="_blank" rel="external">http://wilbeibi.com/2015/05/2015-05-09-K_edit_distances/</a><br><a href="https://gist.github.com/Wilbeibi/46afba947d929cc7a0c8" target="_blank" rel="external">https://gist.github.com/Wilbeibi/46afba947d929cc7a0c8</a><br><a href="http://www.zhihu.com/question/29592463" target="_blank" rel="external">http://www.zhihu.com/question/29592463</a></p>
<h2 id="Tools">Tools</h2>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/" target="_blank" rel="external">可视化</a><br><a href="http://www.sorting-algorithms.com/" target="_blank" rel="external">排序</a><br><a href="http://en.wikibooks.org/wiki/LaTeX/Mathematics" target="_blank" rel="external">latex:Mathematics</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Overview">Overview</h2>
<p>It takes me half year to finish the CLRS and learn a lot. This is my notes about the legendary book.</p>
<p>I have read the whole book and take the online <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/" target="_blank" rel="external">MIT open Course</a>. Thanks MIT for the online course.<br>I’ve also get resource from Chinese and English forum.</p>
<p>I want to share my note to other guy who is interested in the algorithm and thinking.<br>Please feel free to check it out. Hope it’s helpful to you. Thank you.</p>
]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[My TCP/IP Notes]]></title>
    <link href="http://yoursite.com/2015/04/04/My-TCP-IP-Notes/"/>
    <id>http://yoursite.com/2015/04/04/My-TCP-IP-Notes/</id>
    <published>2015-04-05T02:09:27.000Z</published>
    <updated>2015-04-05T03:28:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="TCP/IP_详解(卷1:协议)">TCP/IP 详解(卷1:协议)</h1>
<p>这是我阅读 <a href="http://book.douban.com/subject/1088054/" target="_blank" rel="external">TCP/IP详解</a> 的笔记，有了新内容会持续进行更新，谢谢！</p>
<h1 id="概述">概述</h1>
<p>tcp/ip 四层协议:</p>
<ul>
<li>链路层：设备驱动程序及接口卡</li>
<li>网络层：处理分组在网络中的活动</li>
<li>运输层：为两台主机上的应用程序提供端到端的通信</li>
<li>应用层：处理应用程序细节<a id="more"></a>
</li>
</ul>
<p>应用层用到End-to-end协议,端到端<br>网络层是Hop-by-hop协议,点到点</p>
<p>网络层IP是不可靠的服务，只是尽可能快地把分组从源节点送到目的节点，但是不保证可靠<br>TCP在不可靠的IP层上提供了可靠的运输层，使用了超时重传，发送和接收端到端的确认分组等机制</p>
<p>路由器:在IP层把网络连在一起</p>
<p>以太网数据帧的物理长度在46~1500字节之间</p>
<p><img src="http://i.imgur.com/yOTtMgW.png" alt=""></p>
<h1 id="链路层">链路层</h1>
<h2 id="链路层-1">链路层</h2>
<p>TCP/IP支持多种不同的链路层协议，取决于网络所使用的硬件，如以太网，IEEE，SLIP，PPP封装格式</p>
<p>loopback interface:127.0.0.1 localhost</p>
<p>最大传输单元MTU:1500和1492字节等，不同传输介质有不同的MTU<br>如果IP层有一个数据报要传，数据长度比链路层MTU大，那就要分片fragmentation<br>路径MTU:重要的不是两台主机所在的网络的MTU值，而是两台通信主机路径中最小MTU，被称为路径MTU<br>两台主机之间的路径MTU不一定是个常数，他取决于所选择的路由，选路也不一定是对称的，所以路径MTU在两个方向上不一定是一致的。</p>
<h3 id="环回接口">环回接口</h3>
<p>127.0.0.1 localhost</p>
<ul>
<li>传给环回地址的任何数据都作为ip输入</li>
<li>传给广播或多播地址的数据报复制一份传给环回接口，然后送到以太网</li>
<li>任何传给该主机ip地址的数据均送到环回接口</li>
</ul>
<p>环回接口可以被看做网络层下面的另一个链路层，网络层把一份数据报传给环回接口，就像传给其他链路层一样，只不过环回接口把它返回到ip的输入队列</p>
<h2 id="ARP">ARP</h2>
<h3 id="引言">引言</h3>
<p>ARP为ip地址到对应的硬件地址之间提供了动态映射</p>
<h3 id="例子">例子</h3>
<p>网络接口有一个硬件地址，48bit的值<br>tcpip有自己的地址：32bit的ip地址<br>内核必须知道目的端的硬件地址才能发送数据<br>ARP的功能就是在32bit的ip地址和采用不同网络技术的硬件地址之间提供动态映射</p>
<p>ARP发送一份称为ARP请求的以太网数据帧给以太网上的每一个主机，这个过程称作广播</p>
<h3 id="ARP高速缓存">ARP高速缓存</h3>
<p><code>arp -a</code><br>每个主机上都有一个ARP高速缓存，每一项大概20分钟存活时间<br>48bit的以太网地址用6个十六进制来标示</p>
<h3 id="ARP的分组格式">ARP的分组格式</h3>
<p>电缆上的所有以太网接口都要接受广播的数据帧</p>
<h3 id="ARP例子">ARP例子</h3>
<p>ff:ff:ff:ff:ff:ff 是以太网广播，电缆上的每个以太网接口都要接受这个数据帧对它进行处理，以太网最小长度是60字节，ARP请求或者回答的数据帧都是42字节，所以每一帧都必须加入填充字符以达到以太网的最小长度要求，有一些书最小长度64字节，因为算了4字节的以太网帧尾</p>
<p>ARP request is broadcast，The ARP reply is sent directly to the requesting host; it is not broadcast.</p>
<p>请求不存在主机的ARP请求时，会超时，tcpdump命令输出的超时限制是29.5秒，大多数BSD实现把完成TCP连接请求的时间限制为75秒</p>
<p>直到ARP回答返回，tcp报文段才可以被发送，因为硬件地址这时候才知道</p>
<p>完整表项超时20分钟，不完整3分钟</p>
<h3 id="ARP代理">ARP代理</h3>
<p>如果ARP请求时从一个网络主机发往另一个网络的主机，那么连接这<strong>两个网络</strong>的路由器就可以回答该请求，这个过程称作委托ARP或者ARP代理(Proxy ARP)，路由器的功能相当于目的主机的代理</p>
<p>路由器识别出ip地址术语它的一个拨号主机，于是它把自己的以太网接口地址作为硬件地址来回答</p>
<h3 id="免费ARP">免费ARP</h3>
<p>主机发送ARP查询自己的ip地址</p>
<p>两个作用:</p>
<ul>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的ip地址</li>
<li>如果发送免费arp的主机改变了硬件地址，那么这个额分组就可以使其他主机告诉缓存中的旧的硬件地址进行相应的更新</li>
</ul>
<h3 id="ARP命令">ARP命令</h3>
<p><code>-a</code>显示<code>-d</code>删除<code>-s</code>增加</p>
<h2 id="ICMP:internet控制报文协议">ICMP:internet控制报文协议</h2>
<h3 id="引言-1">引言</h3>
<p>ICMP传递差错报文和其他需要注意的信息<br>ICMP报文前四个字节是一样的，剩下的其他字节互不相同<br><img src="http://i.imgur.com/pP6SZBs.png" alt=""></p>
<h3 id="ICMP报文的类型">ICMP报文的类型</h3>
<p><img src="http://i.imgur.com/TZIED64.png" alt=""></p>
<h3 id="ICMP地址掩码请求与应答">ICMP地址掩码请求与应答</h3>
<p>请求报文进行广播，然后打印所有应答，广播会包括自己的环回地址</p>
<p>RFC规定，除非系统是地址掩码的授权代理，否则不能发送地址掩码应答，但是大多数主机收到请求时都发送一个应答，甚至还是错误的应答，有bug</p>
<h3 id="ICMP时间戳请求与应答">ICMP时间戳请求与应答</h3>
<p>请求允许系统向另一个系统查询当前的时间<br>difference减去RTT的一半，就是调整值</p>
<h3 id="ICMP端口不可达差错">ICMP端口不可达差错</h3>
<p>这是一种差错报文<br>UDP的规则之一，如果收到一份udp数据报而目的端口与某个正在使用的进程不相符合，那么udp返回一个icmp不可达报文，可以用TFTP强制生成一个端口不可达报文</p>
<p>差错报文，必须包括差错报文的数据报IP首部，还必须至少包括跟在ip首部后面的前8个字节</p>
<p>包含在udp和tcp首部中的内容是源端口号和目的端口号</p>
<p><img src="http://i.imgur.com/kaeSChm.png" alt=""></p>
<h1 id="应用层">应用层</h1>
<h2 id="ping程序">ping程序</h2>
<h3 id="引言-2">引言</h3>
<p>目的为了测试另一台主机是否可达，程序发送一份icmp回显请求报文给主机，并等待返回icmp回显应答</p>
<h3 id="ping程序-1">ping程序</h3>
<p>允许观察分组丢失，失序，重复</p>
<p>LAN输出:当前时间减去icmp报文中的时间，就是往返时间，ttl位于ip首部<br>第一个返回时间要大因为arp请求</p>
<p>wan输出:有可能丢失分组，或者有重复或者失序的分组</p>
<p>slip：比较慢</p>
<h3 id="ip记录路由选项">ip记录路由选项</h3>
<p>ping程序提供-R选项，提供记录路由的功能，记录经过的所有路由器的地址，但是ip首部只有有限的空间来存放ip地址，37个字节可以(60-20-3)，3个是rr选项，20个师首部，所以只能存放<strong>9个ip地址</strong><br>由于有限制，所以用Traceroute工具更好<br>始终把出口的ip地址加入清单中，然后把自己的入口ip地址也加入清单中</p>
<p><img src="http://i.imgur.com/gz0HlDE.png" alt=""></p>
<h2 id="Traceroute程序">Traceroute程序</h2>
<h3 id="引言-3">引言</h3>
<p>可以让我们看到ip数据报从一台主机传到另一台主机所经过的路由</p>
<h3 id="Traceroute操作">Traceroute操作</h3>
<p>为什么要取代ping -R</p>
<ul>
<li>不是所有路由器都支持记录路由选项，Traceroute不需要中间路由器具备任何特殊的功能</li>
<li>路由记录一般是单向的选项</li>
<li>ip首部留给选项的空间有限，不能存放太多的路径</li>
</ul>
<p>Traceroute利用ICMP报文和ip首部的TTL字段(生存周期)</p>
<p>每个处理数据报的路由器都需要把TTL的值减1或减去在路由器中停留的秒数</p>
<p>TTL字段的目的是为了防止数据报在选路时无休止的在网络中流动</p>
<p>当路由器收到一份ip数据报，如果TTL为0或1，那路由器不转发数据报，路由器丢弃数据报，并发给源机一份ICMP“超时”信息，Traceroute程序通过这份ICMP信息的ip报文知道路由器的ip地址</p>
<p>先发送TTL为1的，然后发2，以此类推</p>
<p>Traceroute程序发送一份UDP数据报给目的主机，但是选择了一个不可能的值作为UDP端口号(大于30000)，目的主机产生<strong>端口不可达错误</strong></p>
<p>Traceroute程序区别接受到的<strong>ICMP超时</strong>或者<strong>ICMP端口不可达</strong>，就能知道所有的信息</p>
<h3 id="局域网输出">局域网输出</h3>
<p>第一行</p>
<ul>
<li>目的主机名和ip地址</li>
<li>最大TTL值 hops max</li>
<li>字节数(20字节ip首部，8字节udp首部和用户数据)</li>
</ul>
<p>对于每个TTL值，发送三份数据报，每季收到一份ICMP报文，打印往返时间，5秒内没收到任意一份，就打一个星号<br>Traceroute给出的时总往返时间</p>
<p>注意</p>
<ul>
<li>不能保证现在的路由就是将来的路由，甚至两份连续的ip数据报都有可能采用不同的路由</li>
<li>不能保证icmp报文的路由鱼Traceroute程序发送的ucp数据报采用同一种路由，往返时间可能不能真正体现数据发出和返回的时间差</li>
<li>icmp报文中的信源ip地址是udp数据报到达的<strong>路由器接口</strong>的ip地址，而ping是<strong>发送接口地址</strong>，所以从A到B运行Traceroute和从B到A运行Traceroute所得到的结果是不同的</li>
<li>Traceroute程序获得是ip地址，所以给定ip地址的情况下，要做一个反向域名查看来获取域名</li>
</ul>
<h3 id="广域网输出">广域网输出</h3>
<p>同一个地点有时候时间会有很大的差别，不能区分是发出的数据报还是返回的icmp差错数据报被拦截</p>
<h3 id="ip源站选路选项">ip源站选路选项</h3>
<p>源站选路(source routing)的思想史由发送者制定路由</p>
<ul>
<li>严格的源站路由选择，发送端志明ip之举报所必须经过的确切路由，如果路由器发现源路由所指定的下一个路由器不在其直接连接的网络上，它返回一个“源站路由失败”的ICMP差错报文</li>
<li>宽松源站选择，发送端志明了一个数据报经过的ip地址清单，但是数据报在清单上指明的任意两个地址之间可以通过其他路由器</li>
</ul>
<p>源站路由，必须在发送ip数据报钱填充ip地址清单，数量小于9个</p>
<p>源站路由运行过程：</p>
<ul>
<li>发送主机从应用程序接受源站路由清单，将第一个表项去掉，将所有剩余的项左移1个位置，并将原理啊的目的地址作为清单的最后一个</li>
<li>每个处理数据报的路由器检查其是否为数据报的最终地址，不是的话就转发数据报</li>
<li>如果该路由器是最终目的，且指针不大于路径的长度<br><img src="http://i.imgur.com/H6JQIPR.png" alt=""></li>
</ul>
<p><code>-g</code>是宽松路由选战的选项<br>最多制定8个中间路由器，最后一个是目的主机<br>会丢失路由器，这些丢失的路由器可能发生了与宽松路由选战选项数据有关的程序问题，所以没有显示<br>有星号说明失败，5秒内没有应答</p>
<p><code>-G</code>严格路由选路<br>!S表明失败，失败时发送<strong>源站路由失败</strong>的差错报文</p>
<p> 可以通过宽松的源站选路来进行往返路由</p>
<h1 id="IP_层">IP 层</h1>
<h2 id="IP">IP</h2>
<h3 id="引言-4">引言</h3>
<p>不可靠(unreliable):不能保证IP数据报能成功地到达目的地<br>无连接(connectionless):不维护任何后续数据报的状态信息，每个数据报都是相互独立的，可以不按发送顺序接收，每个数据报独立地进行路由选择，可能选不同的路线。</p>
<h3 id="IP首部">IP首部</h3>
<p><img src="http://i.imgur.com/BXxEwJ3.png" alt=""></p>
<p>版本号:现在时4<br>首部长度:首部占32bit字的数目，不含选项时，普通IP数据报是5(4<em>5=20字节)，如果有选项，最大是60字节(4</em>15=60)<br>服务类型:TOS,代表最小时延，最大吞吐量，最高可靠性，最小费用，只有一个为1bit，全为0就是一般服务<br>总长度:整个ip数据报的长度，最大65534，但是大多数情况会分片。由于一些链路层要填充数据达到最小长度，所以总长度字段可以知道有多少是ip数据报的内容<br>表示字段:唯一标示主机发送的每一份数据报<br>TTL:设置了数据报可以经过的最多路由器数，每经过一个减1，到0时数据报被丢弃<br>协议字段:识别哪个协议向ip传送字段<br>首部检验和字段根据ip首部计算的检验和码，不对后面的数据进行计算<br>发送方计算检验和放入，接收方计算所有的，全为1时说明正确，不是全1时丢弃，但是不产生差错报文，由上层发现，每通过一个路由器ttl减1，检验和增加</p>
<h3 id="IP路由选择">IP路由选择</h3>
<p>路由表信息:</p>
<ul>
<li>目的ip地址</li>
<li>下一站路由器ip地址</li>
<li>标志</li>
<li>网络接口</li>
</ul>
<p>ip路游:</p>
<ul>
<li>搜索路由表，寻找目的ip地址完全匹配的表目，<strong>网络号和主机号</strong></li>
<li>寻找与网络号相匹配的表目，<strong>网络号</strong></li>
<li>使用默认表目</li>
</ul>
<p>关键:</p>
<ul>
<li>数据报中的ip地址始终不发生变化</li>
<li>每一次的链路层地址都不同，链路层地址指向下一站的链路层地址</li>
</ul>
<h3 id="子网寻址">子网寻址</h3>
<p>ip地址由网络号和主机号组成<br>主机号可以分为子网号和主机号<br>16bit的主机号，8bit子网号，8bit主机号，就有254个子网，每个子网有254主机</p>
<p>子网对外部路由器是隐藏内部网络组织的<br>使用子网的B类地址，可以缩小internet路由器的规模，对外的路由器是透明的，只需要一个路由器表，缩小了路由表的规模</p>
<p>子网对子网内部的路由器是不透明的</p>
<h3 id="子网掩码">子网掩码</h3>
<p>除了ip地址外，主机还需要知道多少比特用于子网号及多少比特用于主机号，所以需要子网掩码<br>子网掩码:值为1的比特留给网络号和子网号，为0的比特留给主机号</p>
<p>这样，给定了ip地址和子网掩码以后，主机就可以确定数据报的目的</p>
<ul>
<li>本子网上的主机</li>
<li>本网络中其他子网的主机</li>
<li>其他网络的主机</li>
</ul>
<p>知道ip地址，就知道他是否为a,b,c类，从ip地址高位得知，也就知道了网络号和子网号之间的分界线，通过子网掩码知道子网号和主机号的分界线</p>
<h3 id="特殊情况的ip地址">特殊情况的ip地址</h3>
<p>特殊源地址，环回地址，广播地址</p>
<h3 id="子网例子">子网例子</h3>
<p>变长子网:一个子网的网络使用多个子网掩码<br>11位子网中，前8位始终是13，后面3bit表示不同的子网，001表示以太网，010表示slip链路，对外来说只要知道13在哪里就行，对于内部的sun主机来说知道变长子网就行了</p>
<p><img src="http://i.imgur.com/G8Cludv.png" alt=""></p>
<h3 id="ifconfig命令">ifconfig命令</h3>
<p>tcpip对网络接口进行配置和查询的命令</p>
<h3 id="netstat命令">netstat命令</h3>
<p>netstat -in<br>提供系统上的接口信息</p>
<h2 id="IP选路">IP选路</h2>
<h3 id="引言-5">引言</h3>
<p>主机必须配置成一个路由器，否则通过网络接口接收到的数据报，如果目的地址不是本机就会被丢弃</p>
<h3 id="路由原理">路由原理</h3>
<p>内核维护路由表，路由表包含的信息决定了ip层所做的所有决定</p>
<p>ip搜索路由表步骤：</p>
<ol>
<li>搜索主机地址</li>
<li>搜索网络地址</li>
<li>搜索默认表项</li>
</ol>
<p>ip执行选路机制，路由守护程序提供选路策略</p>
<p><code>netstate -rn</code>显示路由表，显示ip地址</p>
<p>flag：</p>
<ul>
<li>U 该路由可用</li>
<li>G 该路由是一个网关（路由器），没有设置该标志说明目的地是直接相连的</li>
<li>H 是一个主机</li>
<li>D 该路由是由重定向报文创建</li>
<li>M 路由已经重定向报文修改</li>
</ul>
<p>G:区分间接路由和直接路由，对于直接路由不设置标志G<br>直接路由：目的地端的ip地址+链路层地址<br>间接路由：最终目的地的ip地址+下一站路由器的链路层地址</p>
<p>H:目的地址是一个完整的主机地址<br>没有设置说明是一个网络地址<br>为了某个ip搜索路由表时，主机地址项必须完全与目的地址匹配，而网络地址只西药匹配目的地址的网络号和子网号就ok了</p>
<p>refs:正在使用路由的活动进程个数<br>use:通过该路由发送的分组数<br>interface:本地接口</p>
<p>初始化路由<br>初始化一个接口时，创建直接路由<br>对于点对点链路和环回接口，路由到达主机，H标志<br>对于广播接口，以太网等，路由是网络<br><code>route</code>命令增加路由表的表项</p>
<p>复杂的路由表:<br>有可能有多个接口<br>netstate为直接路由打印出来的网关地址就是本地接口所用的ip地址</p>
<p>没有目的的路由<br>没有默认项和匹配项<br>本机产生:给发送该数据报的应用程序返回一个差错，<strong>主机不可达差错</strong>或者<strong>网络不可达差错</strong><br>如果是转发数据报，给原始发送端一份ICMP主机不可达的差错报文</p>
<h3 id="ICMP主机与网络不可达差错">ICMP主机与网络不可达差错</h3>
<p>返回主机不可达的回显请求报文</p>
<p>顶层选路域，有可能没有默认项，所以会返回不可达的回显请求报文</p>
<h3 id="ICMP重定向差错">ICMP重定向差错</h3>
<p>当ip数据报应该被发送到另外一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给ip数据报的发送端</p>
<p><img src="http://i.imgur.com/vDFWdlK.png" alt=""></p>
<p>重定向报文标志位D</p>
<h3 id="ICMP路由器发现报文">ICMP路由器发现报文</h3>
<p>初始化路由表的方法:</p>
<ul>
<li>配置文件中制定静态路由，经常用来设置默认路由</li>
<li>利用ICMP路由器通告和请求报文<br>主机在引导之后广播或者多播传送一份路由器请求报文，一台或多台路由器响应一份路由器通告报文。<br>路由器定期地广播或多播传送他们的路由器通告报文，允许每个监听的主机相应更新路由表</li>
</ul>
<p>路由器操作</p>
<ul>
<li>路由器启动时，广播或者多播接口上发送通告报文，不定期随机发送，450到600秒，生命周期30分钟</li>
<li>路由器关闭时，发送最后一份通告报文，生命周期为0</li>
<li>路由器监听来自主机的请求报文，发送路由器通告报文回应</li>
<li>多台路由器，系统管理员来设置路由器的设置优先级别</li>
</ul>
<p>主机操作</p>
<ul>
<li>引导期间发送三份路由器请求报文，收到一份有效的就停止</li>
<li>监听来自相邻路由器的请求报文</li>
</ul>
<h2 id="动态选路协议">动态选路协议</h2>
<h3 id="引言-6">引言</h3>
<p>静态选路：</p>
<ul>
<li>配置接口时，默认方式生成路由表项</li>
<li>通过route命令</li>
<li>通过ICMP重定向生成表项<br>限制：</li>
</ul>
<ol>
<li>网络很小</li>
<li>与其他网络知有单个连接点</li>
<li>没有多余路由时可行</li>
</ol>
<p>如果3个限制不能全部满足，通常用动态路由</p>
<ul>
<li>RIP(routing information protocal)</li>
<li>OSPF</li>
<li>BGP</li>
<li>无分类域间选路的新的选路技术</li>
</ul>
<h3 id="动态选路">动态选路</h3>
<p>相邻路由器进行通信，告知对方每个路由器所在网络，就是动态选路，有一个路由守护程序维护routing daemon</p>
<p>当路由随时间变化，路由是由路由守护程序进行增加或者删除，而不是来自于引导程序的route命令<br>路由守护程序有选路策略，维护路由表</p>
<p>internet以自治系统组织(AS,Autonomous system)</p>
<p>每个自治系统可以选择该自治系统中各个路由器之间的选路协议</p>
<ul>
<li>内部网关协议IGP(Interior Gateway protocol)</li>
<li>域内选路协议(intradomain routing protocol)</li>
<li>常用的时RIP</li>
</ul>
<p>外部网关协议</p>
<ul>
<li>EGP</li>
<li>BGP</li>
</ul>
<p><img src="http://i.imgur.com/Oy9eKCM.png" alt=""></p>
<h3 id="RIP选路信息协议">RIP选路信息协议</h3>
<p><img src="http://i.imgur.com/EuX3zdr.png" alt=""></p>
<p>运行，RIP常用UDP端口是520</p>
<ul>
<li>初始化：启动一个守护程序，判断启动哪些接口，每个接口上发送一个请求报文，要求其他路由器发送完整路由表，命令字段为1，地址字段为0，度量字段16这事一份要求另一端完整路由表的特殊请求报文</li>
<li>接收到请求，处理请求中每一个表项</li>
<li>接受响应，更新路由表</li>
<li>定期选路更新，每过30秒，所有或者部分路由器发送完整路由表给相邻路由器，广播或者点对点</li>
<li>触发更新</li>
</ul>
<p>每个路由都有与之相关的定时器，如果rip发现系统中一条路有3分钟没有更新了，就设置为16，标注为删除</p>
<p>度量:<br>度量以跳hop计算，直接连接的接口跳数为1<br><img src="http://i.imgur.com/DkaACsB.png" alt=""><br>每个路由器都发送其路由表给相邻站，如果在AS内从一个路由器到一个网络有多条路由，选择跳数小的<br>跳数最大是15，16表示无法到达的ip地址</p>
<p>问题</p>
<ul>
<li>没有子网概念</li>
<li>发生故障后要很长时间稳定下来</li>
<li>度量15限制了rip的网络大小</li>
</ul>
<h3 id="RIP_版本2">RIP 版本2</h3>
<p>利用了版本1中必须为0的一些字段传递信息</p>
<p>选路域<br>选路标记<br>子网掩码<br>下一站ip地址</p>
<h3 id="OSPF开放最短路径优先">OSPF开放最短路径优先</h3>
<h3 id="BGP边界网关协议">BGP边界网关协议</h3>
<p>IGP:RIP<br>EGP:BGP<br>还在研究和发展</p>
<h1 id="UDP">UDP</h1>
<h2 id="UDP-1">UDP</h2>
<h3 id="引言-7">引言</h3>
<p>UDP是一个简单的面向数据报的运输层协议，进程的每个输出操作正好产生一个UDP</p>
<h3 id="UDP首部">UDP首部</h3>
<p><img src="http://i.imgur.com/av15yfg.png" alt=""></p>
<p>UDP长度字段指的是UDP首部和UDP数据的字节长度，最小为8个字节</p>
<h3 id="UDP检验和">UDP检验和</h3>
<p>UDP检验和覆盖UDP首部和UDP数据<br>IP首部检验和只覆盖IP的首部，不包括数据包中的任何数据</p>
<p>UDP检验和是可选的，UDP和TCP数据报都含有一个12字节的伪首部<br><img src="http://i.imgur.com/AFSLHAZ.png" alt=""></p>
<p>计算检验和为奇数长度就填充0<br>检验和计算为0，就存入全1<br>如果检验和为0，说明发送端没有计算检验和</p>
<p>UDP检验和(包括tcpip所有的检验和)是简单的16bit和，检验不出交换两个16bit的差错</p>
<p>不是所有的以太网数据帧都是ip数据报，至少还有arp协议<br>不是所有的ip数据报都是udp或tcp数据，icmp也用ip传送数据</p>
<h3 id="IP分片">IP分片</h3>
<ul>
<li>ip把mtu与数据报长度进行比较，如果需要分片，分片可以发生在发送端主机，也可以在中间路由器</li>
<li>每一份ip数据包分片以后，只有到达目的地才进行重新组装，组装由ip层完成，目的是让分片和充足对运输层透明</li>
<li>发送端发送的每份ip数据报，标识字段都包含一个唯一值，该值在数据报分片时被复制到每个片中。标识字段用其中一个比特标识“更多的片”，除了最后一篇，其他都是1。片偏移字段指的是该片偏移原始数据包开始处的位置，数据报备份片后，每个片的总长度都要改成改片的长度</li>
<li>标志字段有一个比特位“不分片”位，如果是1，ip将不对数据报进行分片，相反会丢弃并发送一个icmp差错报文（需要进行分片但设置了不分片比特）</li>
<li>被分片后，每个片都成为一个分组，都有自己的ip首部，路由时也是独立的，到达时时失序的，但是有足够信息重组</li>
<li>即使丢失一片数据，也要重传所有<br><img src="http://i.imgur.com/phWGLHP.png" alt=""><br>frag是标识字段的值<br>@前面是数据长度，后面是偏移量</li>
</ul>
<p><img src="http://i.imgur.com/GQ3KAlB.png" alt=""><br>分组和数据报区别</p>
<h3 id="ICMP不可达差错(需要分片)">ICMP不可达差错(需要分片)</h3>
<p>通过ping程序，逐步增加数据分组长度，知道看见进入的分组被分片为止</p>
<h3 id="Traceroute确定路径MTU">Traceroute确定路径MTU</h3>
<p>设置Traceroute不分片，逐步减小分组长度，如果路由器发送的icmp错误报文是新格式，包含出口的mtu，那就用这个作为下一个mtu值来发送，不用依次减少来不断测试</p>
<p>利用mtu发现机制，应用程序可以充分利用更大的mtu来发送报文</p>
<h3 id="采用udp的路径mtu发现">采用udp的路径mtu发现</h3>
<p>ip当知道发往该目的地址的数据报不能将DF比特置1，因此，ip要对数据报进行分片<br>建议每10分钟来查看MTU是不是变大了</p>
<h3 id="UDP和ARP之间的交互作用">UDP和ARP之间的交互作用</h3>
<p>当arp没有缓存时，发送一个8192自己的udp数据报，会产生6个数据报片—ip分片</p>
<p>每个分片都会有arp请求。<br>收到arp应答时，只将最后一个报文发送到制定目的主机<br>这事ARP洪范，arp flooding，高速率重复发送到同一个ip地址的arp请求</p>
<p>而且没有icmp组装超时差错<br>因为一般来说，第一个数据报片出现，ip必须启动一个定时器，30秒或者60秒，如果定时器超时那这个数据报的所有数据片未能全部到达，就全部丢弃</p>
<p>没看到有两个原因</p>
<ul>
<li>berkeley派生的不产生这个差错</li>
<li>没有接收到包含udp首部的偏移量为0的第一个数据报片，除非第一个数据报片到达，不然不知道运输层的首部，无法区分是哪个进程发送的数据报被丢弃</li>
</ul>
<p>大多数arp实现在等待arp应答时只保留最近传送给目的端的数据报</p>
<h3 id="最大UDP数据报长度">最大UDP数据报长度</h3>
<p>理论最大ip长度65535，取出首部是65507字节，但是有两个限制导致数值小</p>
<ol>
<li>应用程序可能会受到程序接口的限制</li>
<li>tcpip的内核实现限制</li>
</ol>
<h3 id="ICMP源站抑制差错source_quench">ICMP源站抑制差错source quench</h3>
<p>接受数据报的速度比处理的速度快，就可能产生这个差错<br>“可能”是因为即使一个系统没有缓存并丢弃数据报，可不要求它一定要发送源站抑制报文</p>
<p>新的RFC中，提出路由器不应该产生这个报文，因为他小号网络带宽，而且对拥塞来说是一种无效而且不公平的调整</p>
<h3 id="UDP服务器的设计">UDP服务器的设计</h3>
<p>通常一个客户启动后直接鱼单个服务器通信，然后就结束了，而对于服务器来说，它启动后处于休眠，等待客户请求的到来，对于udp，客户数据报到达时，服务器苏醒</p>
<p>需要客户ip地址和端口号</p>
<p>需要目的ip地址，因为有广播</p>
<p>UDP输入队列<br>单个服务器进程对单个udp端口上的所有客户请求进行处理<br>udp自动排队，接收到的udp数据报以其接受顺序给应用程序</p>
<p>排队会溢出</p>
<ul>
<li>应用程序不知道输入队列何时溢出，只是udp对超时数据报进行丢弃处理</li>
<li>没有发回任何信息告诉客户数据报被丢失</li>
<li>udp是fifo</li>
<li>arp是lifo</li>
</ul>
<p>可以限制本地ip地址的端口和远端ip地址的端口，通常一个程序端口与某个本地ip地址及udp端口号想关联</p>
<h2 id="广播和多播">广播和多播</h2>
<h3 id="引言-8">引言</h3>
<p>三种ip地址</p>
<ul>
<li>单播</li>
<li>广播</li>
<li>多播</li>
</ul>
<p>广播和多播仅仅用于tcp，他们对需要将报文同时传给多个接受者的应用十分重要。<br>tcp是一种面向连接的协议，是两个主机内的两个进程间的一个连接</p>
<p>广播:向网上的所有其他主机发送帧<br>多播:单播和广播之间</p>
<p>接口会被设置为混杂模式，这种模式能接收到每个帧的一个复制，如tcpdump</p>
<p>多播地址:01:00:00:00:00:00<br>广播地址:ff:ff:ff:ff:ff:ff</p>
<p>广播会增加对广播数据不感兴趣主机的处理负荷<br>多播减少了应用不感兴趣主机的处理负荷，使用多播可以加入一个或者多个多播组</p>
<h3 id="12-2_广播">12.2 广播</h3>
<p>受限的广播地址:255.255.255.255<br>该地址用于主机配置过程中ip数据报的目的地址<br>系统初始启动时用</p>
<p>任何情况，都不转发受限的，仅仅出现在本地网络中</p>
<p>指向网络的广播<br>A类,netid.255.255.255</p>
<p>指向子网<br>128.1.2.255<br>子网掩码255.255.255.0</p>
<p>指向所有子网的广播<br>128.1.255.255</p>
<h3 id="广播的例子">广播的例子</h3>
<p>相应广播前，发送arp请求</p>
<h3 id="多播">多播</h3>
<p>ip多播服务</p>
<ul>
<li>向多个目的地址传送数据</li>
<li>客户对服务器的请求</li>
</ul>
<p>能够接受王法一个特定多播组地址数据的主机集合成为主机组，一个主机组可以跨越多个网络，主机中的成员随时可以加入或者离开主机组，主机组对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送消息</p>
<p>多播组地址到以太网地址映射转换</p>
<h2 id="IGMP:Internet_组管理协议">IGMP:Internet 组管理协议</h2>
<p>多播的一组协议</p>
<h2 id="DNS">DNS</h2>
<h3 id="引言-9">引言</h3>
<p>主机名字和 ip 地址之间的转换<br>解析器通常是应用程序的一部分。在一个应用程序请求 TCP 打开一个连接或使用 UDP 发送一个数据报之前，必须将一个主机名转换成一个 IP 地址。操作系统内核中的 TCPIP 协议族对于 DNS 一点也不知道</p>
<h3 id="DNS_基础">DNS 基础</h3>
<p>FQDN(full qualified domain name)<br>顶级域名三部分</p>
<ul>
<li>arpa 用于地址到名字转换的特殊域</li>
<li>7个3字符的普通域</li>
<li>所有2字符的国家域名</li>
</ul>
<p><img src="http://i.imgur.com/RkcsLrt.png" alt=""></p>
<p>一个区域的管理者为该区域提供主名字服务器和至少一个辅助名字服务器。主，辅名字服务器必须是独立和冗余的。</p>
<p>每个名字服务器必须知道根的名字服务器。根服务器知道所有二级域中的每个授权名字服务器的名字和位置</p>
<p>超高速缓存</p>
<h3 id="DNS_报文格式">DNS 报文格式</h3>
<p><img src="http://i.imgur.com/0gWpaBd.png" alt=""></p>
<p>查询报文：<br><img src="http://i.imgur.com/zZkdavI.png" alt=""></p>
<p>相应报文<br><img src="http://i.imgur.com/K0nw3Su.png" alt=""></p>
<h3 id="简单的栗子">简单的栗子</h3>
<p>nslookup<br>dig</p>
<p>压缩回答报文</p>
<ul>
<li>返回的结果中包含查询的问题</li>
<li>在返回的结果中会有许多重复的域名，就要用到压缩<br>压缩方法就是用指针，最高位为11，他表示这是一个16bit 指针而不是8bit 的计数字节。指针中的剩下14bit 说明在该 DNS 报文中标识符所在的位置。<br>一个指针可能指向一个完整的域名，也可能指向一个域名的结尾部分。</li>
</ul>
<h3 id="指针查询">指针查询</h3>
<p>给定一个 ip 地址，返回与该地址相应的域名<br>顶级域名arpa 和下面 in-addr 域。当一个组织进入 internet，就获得 DNS 域名空间的授权<code>165.226.125.74.in-addr.arpa</code><br>DNS 名字是由 DNS 树的底部逐渐向上书写的</p>
<pre><code>➜  cs615 git:(master) host <span class="number">74</span>.<span class="number">125</span>.<span class="number">226</span>.<span class="number">165</span>                    
<span class="number">165</span>.<span class="number">226</span>.<span class="number">125</span>.<span class="number">74</span>.<span class="keyword">in</span>-<span class="keyword">addr</span>.arpa domain name <span class="type">pointer</span> lga15s45-<span class="keyword">in</span>-f5.<span class="number">1</span>e100.net.
</code></pre><p>如果 DNS 树中没有独立的分支来处理这种地址名字的转换，就无法反向转换</p>
<h3 id="资源记录">资源记录</h3>
<ul>
<li>A：ip 记录</li>
<li>PTR：指针记录查询，ip 地址被当做 in-addr.arpa 下的一个域名</li>
<li>CNAME：别名 alias，规范名字 canonical name</li>
<li>HINFO：主机信息</li>
<li>NS：名字服务器</li>
<li>MX：邮件交换记录,如果发往 <code>linliu.me</code>，会被提醒发送到<code>smtp.secureserver.net</code>。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  cs615 git:(master) host -t mx linliu.<span class="keyword">me</span> </div><div class="line">linliu.<span class="keyword">me</span> mail <span class="keyword">is</span> handled <span class="keyword">by</span> <span class="number">10</span> mailstore1.secureserver.net.</div><div class="line">linliu.<span class="keyword">me</span> mail <span class="keyword">is</span> handled <span class="keyword">by</span> <span class="number">0</span> smtp.secureserver.net.</div></pre></td></tr></table></figure>

<p><img src="http://i.imgur.com/ODuvld3.png" alt=""><br>第一列域名，第二列寿命值，ttl 为599秒，第三列 IN 就是 internet 类，然后就是类型，然后还有更高的优先值，0或10</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  cs615 git:(master) dig linliu.<span class="keyword">me</span></div><div class="line">;; ANSWER SECTION:</div><div class="line">linliu.<span class="keyword">me</span>.		<span class="number">599</span>	<span class="keyword">IN</span>	A	<span class="number">192.30</span><span class="number">.252</span><span class="number">.154</span></div><div class="line">linliu.<span class="keyword">me</span>.		<span class="number">599</span>	<span class="keyword">IN</span>	A	<span class="number">192.30</span><span class="number">.252</span><span class="number">.153</span></div></pre></td></tr></table></figure>

<h3 id="高速缓存">高速缓存</h3>
<p>高速缓存由 NS 维护。<br>host 命令指出回答不是授权的，因为这个回答来自NS 的高速缓存，而不是来自授权的 NS。</p>
<h3 id="UDP_还是_TCP">UDP 还是 TCP</h3>
<p>大部分时间用 udp<br>当长度超过时，用 tcp，辅助 ns 启动时，使用 tcp 问主ns 查询有没有变化，这里的传输数据很多</p>
<h1 id="TCP">TCP</h1>
<h2 id="TCP-1">TCP</h2>
<ol>
<li>面向连接</li>
<li>可靠的</li>
<li>字节流服务</li>
</ol>
<p>面向连接：</p>
<ul>
<li>交换数据钱要建立一个tcp连接，握手</li>
<li>仅有两方通信</li>
</ul>
<p>可靠:</p>
<ul>
<li>应用数据被tcp分割成合适的发送数据块</li>
<li>发送一个段后，启动定时器，等待目的端确认，不然重发</li>
<li>收到数据，发送一个确认</li>
<li>保持首部和数据的检验和</li>
<li>有可能失序，tcp进行重新排序可以</li>
<li>tcp接收端会丢弃重复数据</li>
<li>提供流量控制，有缓冲空间</li>
</ul>
<p>字节流:</p>
<ul>
<li>两个应用程序交换8bit的字节构成的字节流</li>
<li>tcp不对字节流内容做任何解释，应用层来解释，和unix操作系统的方式很像</li>
</ul>
<p><img src="http://i.imgur.com/HSuunq9.png" alt=""></p>
<p>20字节</p>
<ul>
<li>端口号：一个ip地址和一个端口号成为一个socket，两组这个就是一个唯一的tcp连接双方</li>
<li>序号用来标识从tcp端法相收端的数据字节流，对每个字节进行计数</li>
<li>确认序号包含发送确认的一段所期望的下一个序号，确认序号是上次已成功收到的数据字节序号加1，ack标志为1时有效</li>
<li>全双工服务，两个方向上独立进行传输，每一段都保持每个方向上的传输数据序号</li>
<li>首部长度，最多60字节</li>
<li><p>6个标志比特，多个同时为1<br><img src="http://i.imgur.com/kOAEIZ1.png" alt=""></p>
</li>
<li><p>窗口大小用来流量控制</p>
</li>
<li>强制检验和，tcp首部和tcp数据，还要用伪首部</li>
<li>urg为1时紧急指针有效</li>
<li>可选项中最常见的时mss，maximum segment size</li>
<li>数据部分是可选的，连接建立和终止时，双方报文段只有tcp首部，没有数据，超时时也是只有首部</li>
</ul>
<h2 id="TCP连接的建立与终止">TCP连接的建立与终止</h2>
<h3 id="建立和终止连接">建立和终止连接</h3>
<p>建立连接:三次握手</p>
<ul>
<li>发送SYN段，加上序号</li>
<li>发回SYN报文段，带上确认序号和自己的序号,一个 SYN 占用一个序号</li>
<li>对序号加1发回一个ack<br><img src="http://i.imgur.com/Qwp3BIe.png" alt="enter image description here"><br>初始序号初始化为1，每0.5秒增加64000</li>
</ul>
<p>终止:四次握手<br>因为tcp是半关闭，全双工，所以每次要单独关闭，要4次<br>一个 FIN 占用一个序号</p>
<h3 id="连接建立的超时">连接建立的超时</h3>
<p>第一次6秒，第二次24秒<br>默认建立时长是75秒，如果没有建立成功就放弃</p>
<p>使用定时器</p>
<h3 id="最大报文段长度">最大报文段长度</h3>
<p>MSS表示TCP传往另一端的最大块数据的长度，建立时要告诉对面各自的mss，一般来说越大越好，利用率最高，mss值设置为外出接口上的MTU长度减去固定的ip首部和tcp首部长度，一个以太网就是1460<br>mss选项只能出现在syn报文段中</p>
<p>接受到mss后，发送较小的mss，这样避免分段。如果接口的大，路径中有的比较小，那就要用MTU发现机制</p>
<h3 id="TCP的半关闭">TCP的半关闭</h3>
<p>TCP提供连接的一端在结束它的发送后还能接受来自另一端数据的能力<br>使用FIN</p>
<h3 id="TCP状态变迁图">TCP状态变迁图</h3>
<p><img src="http://i.imgur.com/UhV1JW4.png" alt=""></p>
<p>TIME_WAIT状态也称作2MSL等待状态，这个具体TCP实现必须选择一个报文段最大生存时间MSL，它是任何报文段被丢弃前在网络内的最长时间</p>
<p>结果是2MSL等待时TCP连接的socketip和端口不能再被使用，只有等结束后才能被使用，一般msl时间为30秒，1分钟，2分钟</p>
<p>TCP重启后MSL秒内不能建立任何连接，这个称为平静时间</p>
<h3 id="复位报文段">复位报文段</h3>
<ol>
<li><p>到不存在的端口的连接请求<br>产生复位的常见情况就是目的端口没有在监听</p>
</li>
<li><p>异常终止一个连接<br>FIN是有序释放<br>复位是异常释放<br>优点：</p>
</li>
</ol>
<ul>
<li>丢弃任何带发数据并且利器发送复位报文</li>
<li>另一端知道是异常关闭还是正常关闭，应用程序可以做响应<br>rst报文段包含序号和确认序号，另一端不会产生任何响应<br>收到rst的一方终止连接，并且通知应用层是异常结束</li>
</ul>
<ol>
<li>检测半打开连接<br>一边异常中断另一边不知道，就是板打开</li>
</ol>
<h3 id="同时打开">同时打开</h3>
<p>两个应用程序同时彼此执行主动打开，只建立一条连接<br>进行四次交换<br><img src="http://i.imgur.com/HdqbKhY.png" alt=""></p>
<h3 id="同时关闭">同时关闭</h3>
<p><img src="http://i.imgur.com/8AtB2gM.png" alt=""></p>
<h3 id="TCP选项">TCP选项</h3>
<h3 id="TCP服务器设计">TCP服务器设计</h3>
<p>并发的，多进程或者多线程</p>
<p>到达多个请求，服务器忙的时候，就有队列<br>没有空间的话就丢弃tcp报文，也不发回任何报文<br>队列满时，不理会syn，也不发出rst作为应答</p>
<h2 id="TCP的交互数据流">TCP的交互数据流</h2>
<h3 id="引言-10">引言</h3>
<p>交互数据:Telnet,Rlogin<br>成块数据:FTP,电子邮件，新闻</p>
<h3 id="交互式输入">交互式输入</h3>
<p>Rlogin 连接上键入交互命令,每一个交互按键都产生一个数据分组.<br>因此一个按键就有4个报文<br><img src="http://i.imgur.com/stGRQ7J.png" alt=""></p>
<p>可以合并按键确认和按键回显的报文一起发送,这样就只要3个报文</p>
<h3 id="经过时延的确认">经过时延的确认</h3>
<p>通常 tcp 在接收到数据时并不立即发送 ACK, 而是推迟发送,以便将 ACK 与需要演这个方向的数据一起发送,捎带 ACK, 大部分时延是200MS</p>
<h3 id="Nagle_算法">Nagle 算法</h3>
<p>Rlogin 连接每次发送41个字节长的分组,被称为<strong>小分组</strong><br>在广域网上,小分组太多会引起拥塞,所以使用 Nagle 算法</p>
<p>该算法要求一个TCP 连接上最多只能有一个违背确认的未完成的小分组,该分组的确认到达之前不能发送其他的小分组,相反 TCP 收集这些少量的分组,在确认到来时以一个分组的方式发出去.<br>算法是自适应的,确认的越快,数据发送越快.</p>
<p>在以太网中,回显时延比较快,所以很少使用这个算法.</p>
<p>在广域网中时延大,所以会使用到.客户只有在收到前一个数据的确认后才能发送已经收集的数据,16个字节只要9个报文段</p>
<p>客户端发送3个字节,但是回显1个,这说明服务器端还没有读取完另外两个,但是可以先发送确认的报文段</p>
<h3 id="小结">小结</h3>
<p>Rlogin 一个字节传送<br>Telnet 允许一行<br>小德报文段,使用经受时延的确认,减少报文段数据<br>减慢的广域网,使用 Nagle 算法减少报文段数目</p>
<h2 id="TCP_的成块数据流">TCP 的成块数据流</h2>
<h3 id="引言-11">引言</h3>
<p>滑动窗口协议是一种流量控制方法,该协议允许发送方在停止并等待确认钱可以连续发送多个分组</p>
<h3 id="正常的数据流">正常的数据流</h3>
<p>TCP 的滑动窗口协议,接收方不必确认每一个收到的分组, ACK 是累计的</p>
<p>使用窗口更新来标示窗口有新的空间</p>
<h3 id="滑动窗口">滑动窗口</h3>
<p>三个行为:</p>
<ul>
<li>合拢</li>
<li>张开</li>
<li>收缩,不建议使用<br><img src="http://i.imgur.com/0SNYnEl.png" alt=""></li>
</ul>
<p><img src="http://i.imgur.com/bSqySIk.png" alt=""></p>
<h3 id="窗口大小">窗口大小</h3>
<h3 id="PUSH标志">PUSH标志</h3>
<p>发送方使用该标志通知接收方将所受到的数据全部提交给接受进程,这里的数据包括鱼 PUSH 一起发送的数据以及接收方 TCP 已经为接受进程收到的其他数据。</p>
<p>一个好的 TCP 实现可以自行决定何时设置这个标志</p>
<p>每次写操作清空发送缓存时就发送 PUSH，因为是最后一个报文段</p>
<h3 id="慢启动">慢启动</h3>
<p>当发送方发送太多报文，中间的路由器必须缓存分组，这样会耗尽中间路由器的存储器空间，虽然接收方的还有很多缓存</p>
<p>慢启动 slow start 算法是观察新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作的</p>
<p>慢启动为 tcp 增加了一个窗口：拥塞窗口（congestion window），cwnd。</p>
<p>当建立tcp 连接时，拥塞窗口初始化为1个报文段，没收到一个 ACK，拥塞窗口增加一个报文段。<br>发送方取拥塞窗口与通告窗口中的最小值作为发送上限<br>拥塞窗口是发送方使用的流量控制<br>通告窗口是接收方使用的流量控制<br>启动时，是指数的增长关系<br>在某个点可能达到了互联网的容量，于是中间路由器开始丢弃分组，这就通知发送方它的拥塞窗口过大了。。。。就要用到超时重传机制</p>
<h3 id="成块数据的吞吐量">成块数据的吞吐量</h3>
<p>窗口大小，窗口流量控制，慢启动对于吞吐量的作用</p>
<p>一个分组的时间取决于两个因素</p>
<ul>
<li>传播时延</li>
<li>媒体速率的发送时延</li>
</ul>
<p>通路中，速率较慢时，发送时延主要作用<br>速度快的话就是传播时延主要作用</p>
<p>带宽时延乘积<br>capacity (bits) = bandwidth (bits/sec) x round-trip time (sec)</p>
<p>拥塞<br>当数据到达一个大的管道并向一个较小的管道，就会发生拥塞<br>当多个输入流到达一个路由器，而路由器的输出流小鱼这些输入流的总和时就会发生拥塞</p>
<h3 id="紧急方式">紧急方式</h3>
<h2 id="TCP_的超时与重传">TCP 的超时与重传</h2>
<h3 id="引言-12">引言</h3>
<p>数据丢失时，TCP 通过发送时设置一个定时器解决这个问题，定时器溢出时还没有收到确认，就重传。关键在于超时的间隔和如果确定重传的频率</p>
<p>4个不同的定时器：</p>
<ul>
<li>重传定时器用于希望收到另一端的确认，本节</li>
<li>坚持定时器使窗口大小信息保持不断流动，22节</li>
<li>保活定时器检测一个空闲连接的另一端合适崩溃或重启，23节</li>
<li>2MSL 定时器测量连接 TIME_WAIT 状态的时间，18.6</li>
</ul>
<h3 id="超时与重传的简单例子">超时与重传的简单例子</h3>
<p>使用“指数退避”的方法<br>3，6，12，24，48，多个64秒来进行再一次确认，最后9分钟后放弃，返回错误</p>
<h3 id="往返时间测量">往返时间测量</h3>
<p>往返时间 RTT 测量。</p>
<ol>
<li><p>最初<br>M：测量到的当前 RTT<br>$$R\gets \alpha R+(1-\alpha )M$$<br>a为0.9的平滑因子<br>RTO 超时重传时间<br>$$RTO=R\beta$$<br>$\beta$推荐为2<br>这种方法在 RTT 变化范围很大时，这个方法无法跟上这种变化，会引起不必要的重传，所以用到了<strong>方差</strong></p>
</li>
<li><p>改进<br>$$Err=M-A$$<br>$$A\gets A+gErr$$<br>$$D\gets D+h(|Err|-D)$$<br>$$RTO=A+4D$$<br>A是被平滑的 RTT<br>D室被平滑的均值方差<br>Err 是刚测到的测量结果鱼当前 RTT 估计值的差<br>g 起平均作用，取值1/8<br>偏差的增益 h，取值0.25<br>RTT 变化时，较大的偏差增益会让 RTO 快速上升</p>
</li>
</ol>
<p>karn 算法<br>发出分组时超时，发出多个重传的分组，接收到 ack 时不知道是哪一个，这就是重传多义性的问题<br>所以，当一个超时和重传发生时，在重传数据的确认最后到达时，不更新 rtt 估计器，因为不知道哪一个 ack 对应那次传输<br>由于数据被重传，rto 得到一个指数退避，在下一次传输时使用这个退避后的 rto，对一个没有被重传的报文，除非收到了一个确认，不要计算新的 rto</p>
<h3 id="往返时间_RTT_例子">往返时间 RTT 例子</h3>
<p>RTT 计算不是对所有的报文段<br>每个列检只测量一次 RTT 值，发送一个报文段是，如果定时器已经使用，那么这个报文段不会被计时，只有数据报文会被计时，ACK 是不会被计时的<br>当收到一个包含这个序号的确认后，定时器就会被关闭</p>
<p>RTT 估计的几个过程</p>
<ul>
<li>初始化，A和 D为0和3秒<br>RTO=A+2D=6s<br>初始化2D值在初始化时用，别的时候4D</li>
<li>当 SYN 需要重传时，第一次6秒<br>第二次的计算时间为<br>RTO=A+4D=12s<br>由于指数退避所以两倍24秒<br>当 ACK 重传到达，A 和 D不会更新，因为 Karn 算法，所以还是24秒，虽然有一个 ack 了</li>
<li>到达第一个报文 ack 时<br>A=M+0.5=1.5+0.5=2<br>D=A/2=1<br>RTO=A+4D=6s</li>
<li>第二个 ack 到达<br>按照公式来算 RTO=6.3125<br>浮点原因最后为6s</li>
</ul>
<h3 id="拥塞举例">拥塞举例</h3>
<p>收到3同样的 ack 时，重传<br>接收方不断产生一样的 ack，并且暂时保存接受到的失序数据</p>
<h3 id="拥塞避免算法">拥塞避免算法</h3>
<p>两种分组丢失的指示:发生超时和收到重复的确认<br>拥塞避免算法和慢启动算法要对每个连接维持两个变量</p>
<ul>
<li>一个拥塞窗口 cwnd</li>
<li>一个慢启动门限 ssthresh</li>
</ul>
<p>算法过程:</p>
<ul>
<li>对一个给定连接，初始化 cwnd 为一个报文段，ssthresh 为65535个字节</li>
<li>tcp 输出不能超过 cwnd 和接收方通告窗口的大小</li>
<li>发生拥塞时，ssthresh 被设置为当前窗口大小的一半(cwnd 和接收方通告窗口的最小值)，如果<strong>超时</strong>引起了拥塞，把 cwnd 设置为1个报文段，就是慢启动</li>
<li>当有数据确认时，增加 cwnd，增加的方法依赖于是慢启动还是拥塞避免，cwnd 小鱼 ssthresh 就是慢启动否则就是拥塞避免，慢启动一直持续到当拥塞发生时所处位置的一半的时候才停止转为拥塞避免</li>
</ul>
<p>慢启动:1，2，4，8，对每一个 ack 增加1<br>拥塞避免:每收到一个确认就讲 cwnd 增加1/cwnd，加薪增长，希望在一个往返时间内最多为 cwnd 增加一个报文段</p>
<h3 id="快速重传与快速恢复算法">快速重传与快速恢复算法</h3>
<p>收到失序的报文时，tcp 立即产生一个 ack，不应该被延迟，重复的 ack 目的是让对方知道收到的时一个失序的报文段。<br>收到3个 ack 时，崇春丢失的数据报文段，接下来不是慢启动算法而是拥塞避免算法，这就是快速恢复算法</p>
<p>算法实现</p>
<ol>
<li>收到3个重复的 ack，将 ssthresh 设置为当前拥塞窗口 cwnd 的一半，重传丢失的报文段，设置 cwnd 为 ssthresh 加上3被的报文段大小</li>
<li>每次收到一个重复的 ack，cwnd 增加一个报文段大小并发送一个分组，如果新的 cwnd 允许发送，例子中庸的时 cwnd 取值和未被确认的数据大小比较</li>
<li>下一个确认新数据的 ack 到达时，设置 cwnd 为 ssthresh。这是对第一个步骤的确认也是对中间报文段的确认，这一步采用拥塞避免</li>
</ol>
<h3 id="按每条路由进行度量">按每条路由进行度量</h3>
<p>tcp 连接关闭时可以记录下足够多的数据来统计</p>
<h2 id="TCP_的坚持定时器">TCP 的坚持定时器</h2>
<p>窗口为0时，发送方不发数据，接收方窗口大于0时，返回一个 ack，但是这个 ack 会丢失。这样就导致了死锁。<br>为了防止死锁，发送方使用一个坚持定时器来周期性向接收方查询，以发现窗口是否已经增大</p>
<p>当通告窗口为0，客户停止发送任何其他数据，这就引起了客户设置其坚持定时器，然后以指数退避的方法来不断发送询问，tcp 不会放弃发送窗口探查</p>
<p>糊涂窗口综合征：少量的数据将通过连接进行交换，而不是满长度。<br>接收方：</p>
<ul>
<li>不通告小窗口。接收方不通告一个比当前窗口大的窗口，除非窗口可以增加一个报文段大小或者可以增加接收方缓存的一半<br>发送方：</li>
<li>可以发送一个满长度的报文段</li>
<li>可以发送至少接收方通告窗口大小一半的报文段</li>
<li>能够发送手头的所有数据并且不希望接受 ack</li>
</ul>
<h2 id="TCP_的保活定时器">TCP 的保活定时器</h2>
<p>许多情况下一个服务器希望知道客户主机是否处于崩溃并关机或者崩溃又重启的状态，于是就提供了保活定时器</p>
<p>保活定时器比较有争议，有人认为不应该在 tcp 中实现，而是在应用层中实现</p>
<p>在连接两个端系统的网络出现零时鼓掌时候，保活选项会引起一个实际上很好的连接被终止</p>
<p>如果一个给定的连接两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段</p>
<ul>
<li>客户主机依然正常运行，并从服务器可达</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动</li>
<li>客户主机崩溃并已经重新启动</li>
<li>客户主机正常运行，但是服务器不可达</li>
</ul>
<h2 id="TCP_的未来和性能">TCP 的未来和性能</h2>
<h3 id="路径_MTU_发现">路径 MTU 发现</h3>
<h1 id="更新汇总">更新汇总</h1>
<p>——-First commit 2015/04/04 23:07———————————————————————————————-<br>提交更新 <tcp ip详解=""> 大部分主要内容</tcp></p>
<ul>
<li>TCP</li>
<li>UDP</li>
<li>IP</li>
<li>ICMP</li>
<li>链路层</li>
<li>一些主要应用层协议</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="TCP/IP_详解(卷1:协议)">TCP/IP 详解(卷1:协议)</h1>
<p>这是我阅读 <a href="http://book.douban.com/subject/1088054/" target="_blank" rel="external">TCP/IP详解</a> 的笔记，有了新内容会持续进行更新，谢谢！</p>
<h1 id="概述">概述</h1>
<p>tcp/ip 四层协议:</p>
<ul>
<li>链路层：设备驱动程序及接口卡</li>
<li>网络层：处理分组在网络中的活动</li>
<li>运输层：为两台主机上的应用程序提供端到端的通信</li>
<li>应用层：处理应用程序细节]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用vim反向破解文件]]></title>
    <link href="http://yoursite.com/2015/03/10/%E5%88%A9%E7%94%A8vim%E5%8F%8D%E5%90%91%E7%A0%B4%E8%A7%A3%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2015/03/10/利用vim反向破解文件/</id>
    <published>2015-03-11T03:00:06.000Z</published>
    <updated>2015-03-12T21:20:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>前几天和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>聊到CS615的最后一次大作业，老师开放漏洞让我们去攻击学校的服务器占领首页，然后各小组之间24小时内互相攻击，于是去年做的时候他去服务器上偷偷事先把别人的ssh私钥下载下来了然后取得了胜利，放了一个超级马里奥的游戏上去。。。。。实在是太贱了。。。。</p>
<p>然后<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>继续吹比说，他的文件目录权限设置的特别好，即使一个group的也几乎啥都看不到，不信让我去看看，然后我就真的去看了看，这是配图。。</p>
<p><img src="http://i.imgur.com/IxFMTUW.png" alt="Imgur"></p>
<p>乍一看，除了几个作业的目录和无关紧要的配置文件，别的权限基本都不可读，全被设置好了，但是这一组文件引起了我的兴趣</p>
<p><img src="http://i.imgur.com/PTpwXsp.png" alt="Imgur"></p>
<a id="more"></a>
<h1 id="VIM">VIM</h1>
<p><code>.bashrc</code>也就是bash的配置文件，而<code>.bashrc.swo</code>是使用<strong>vim</strong>时留下的恢复文件，有时候由于各种原因，比如电脑断电，网络原因导致ssh链接断开等等，在编辑vim的时候异常退出了，vim还是能帮你恢复之前正在编辑但是还没有保存的文档，这种机制就需要vim自带的恢复文件，一般第一个恢复文件是叫<code>.swp</code>，第二个是<code>.swo</code>，当再次打开原来的文件时，就会提示你恢复文件。</p>
<p>而在这个系统中，<code>.bashrc</code>是不可读的，所以我自然不可能从这个文件下手，但是<code>.bashrc.swo</code>是可读的，所以我直接把这个文件拷贝了出来，想试试能不能恢复，我试图直接打开这个文件</p>
<pre><code><span class="keyword">vim</span> .bashrc.swo
</code></pre><p>但是结果都是乱码</p>
<p><img src="http://i.imgur.com/siXmHsLm.png" alt="Imgur"></p>
<p>于是我想试试能不能自己编写一个<code>同名空文件</code>，然后让vim自己的机制来恢复回来呢,于是。。。。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>touch .bashrc</div><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>mv .bashrc.swo .bashrc.swp</div><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>ll</div><div class="line">total <span class="number">25</span></div><div class="line">drwxr-xr-x+  <span class="number">2</span> lliu19 student     <span class="number">4</span> <span class="constant">Mar</span> <span class="number">10</span> <span class="number">23</span><span class="symbol">:</span><span class="number">28</span> .</div><div class="line">drwxr-xr-x+ <span class="number">12</span> lliu19 student    <span class="number">20</span> <span class="constant">Mar</span> <span class="number">10</span> <span class="number">23</span><span class="symbol">:</span><span class="number">28</span> ..</div><div class="line">-rw-r--r--+  <span class="number">1</span> lliu19 student     <span class="number">0</span> <span class="constant">Mar</span> <span class="number">10</span> <span class="number">23</span><span class="symbol">:</span><span class="number">28</span> .bashrc</div><div class="line">-rw-r--r--+  <span class="number">1</span> lliu19 student <span class="number">12288</span> <span class="constant">Mar</span> <span class="number">10</span> <span class="number">23</span><span class="symbol">:</span><span class="number">25</span> .bashrc.swp</div><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>vim .bashrc</div></pre></td></tr></table></figure>

<p><img src="http://i.imgur.com/208SiKw.png" alt="Imgur"></p>
<p>大功告成！！！</p>
<p>于是我成功反向恢复了他的配置文件，知道了他ec2的私钥文件地址和文件名，虽然光知道地址还是不能知道破解，但是通过vim自带的恢复机制破解了别人的文件，还是很爽的。。。</p>
<p><img src="http://i.imgur.com/8pSpjLR.png?1" alt="Imgur"></p>
<h1 id="WHY">WHY</h1>
<p>为什么这一招能奏效了，这和linux的权限设置有关，linux在默认创建文件时使用<code>umask</code>去配置权限，例如这是学校服务器的默认umask</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>umask</div><div class="line"><span class="number">0022</span></div></pre></td></tr></table></figure>

<p>也就是说创建文件时默认的是去掉了w权限，保留了r+x权限，所以当在服务器上编辑文件时不小心留下了vim的恢复文件<code>.swp</code>时，就会有权限问题。</p>
<p>但是vim毕竟是老牌编辑器不会想不到这个问题，所以vim在生成<code>.swp</code>恢复文件时，和源文件是一样的读写权限，大家可以去试试。因此之所以会在服务器留下这个文件，有各种原因，有可能在设置权限时没想到有这么贱的方法，只修改了原来的权限，漏掉了vim的配置文件。</p>
<p>虽然这次只是破解了一个配置文件，但是vim编辑的文件里经常会有重要的配置，密码，密钥等等，所以还是要小心的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1>
<p>前几天和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>聊到CS615的最后一次大作业，老师开放漏洞让我们去攻击学校的服务器占领首页，然后各小组之间24小时内互相攻击，于是去年做的时候他去服务器上偷偷事先把别人的ssh私钥下载下来了然后取得了胜利，放了一个超级马里奥的游戏上去。。。。。实在是太贱了。。。。</p>
<p>然后<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>继续吹比说，他的文件目录权限设置的特别好，即使一个group的也几乎啥都看不到，不信让我去看看，然后我就真的去看了看，这是配图。。</p>
<p><img src="http://i.imgur.com/IxFMTUW.png" alt="Imgur"></p>
<p>乍一看，除了几个作业的目录和无关紧要的配置文件，别的权限基本都不可读，全被设置好了，但是这一组文件引起了我的兴趣</p>
<p><img src="http://i.imgur.com/PTpwXsp.png" alt="Imgur"></p>
]]>
    
    </summary>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序员必备的开发工具---MAC]]></title>
    <link href="http://yoursite.com/2015/03/06/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-MAC/"/>
    <id>http://yoursite.com/2015/03/06/程序员必备的开发工具-MAC/</id>
    <published>2015-03-06T06:27:26.000Z</published>
    <updated>2015-03-06T19:24:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>用Mac也1年多了，前半年基本用来打游戏看电影了，由于mac基于unix而来，游戏比较少，好在我只玩dota2，所以对我来说，mac的娱乐性很足。</p>
<p>真正让我感觉离不开Mac的，是我这半年来的学习和开发，在<a href="http://yanguango.com" target="_blank" rel="external">yanguango</a>和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>的帮助下，对mac可以说有了全新的认识，也对linux编程，shell，vim有了更深入的了解。</p>
<h2 id="为什么选择Mac？">为什么选择Mac？</h2>
<p>对于一个程序猿来说，<strong>效率</strong>永远是第一位的，这不仅体现在学习的效率，还有工作编码的效率。在时间平等的情况下，如果才能有更多的<strong>产出</strong>，这一直是程序员所要思考进步的，如何节省<strong>时间</strong>来换取更高的产出呢?答案是——<a href="http://daily.zhihu.com/story/3387025" target="_blank" rel="external">能花钱的，就不要花时间</a></p>
<p>也许有的人说，Mac太贵，对一个还在上学的学生来说压力太大，确实，2000刀的一台mac对于学生党来说是不小的开支，但是如果你有能力，我<strong>极力</strong>劝你先入手一台mac，为什么呢？——<a href="http://www.cnblogs.com/chijianqiang/p/mmac.html" target="_blank" rel="external">先有 Mac 还是先有银元？</a></p>
<p>那有了Mac如何提高效率了，可以看看这篇文章——<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=206041450&amp;idx=1&amp;sn=3982c8cc45d7c47f0fbc19fe8371490f&amp;scene=0#rd" target="_blank" rel="external">程序员效率指南</a></p>
<p><strong>工欲善其事，必选利其器</strong></p>
<p>下面是我自己的一些经验分享，也是我最常使用的一些软件。<br><a id="more"></a></p>
<h2 id="应用&amp;效率">应用&amp;效率</h2>
<h3 id="Alfred_2"><a href="http://www.alfredapp.com/" target="_blank" rel="external">Alfred 2</a></h3>
<p><strong>必装</strong>，Mac下的神器之一，可以使用简单的命令完成相当多的事情</p>
<ul>
<li>定位文件</li>
<li>打开软件</li>
<li>计算器</li>
<li>查询api</li>
<li>google搜索</li>
<li>翻译单词</li>
<li>……</li>
</ul>
<p>自从用了它之后再也不用Dock了,打开应用，查东西比以前效率快<strong>几倍</strong>！<br>最关键的时他支持workflow插件，通过各式各样的<a href="http://www.zhihu.com/question/20656680" target="_blank" rel="external">插件</a>可以实现各种功能!</p>
<p><img src="http://i.imgur.com/pnugYMsm.png" alt="Imgur"><br><img src="http://i.imgur.com/C71WDmom.png" alt="Imgur"></p>
<h3 id="Evernote"><a href="https://evernote.com/premium" target="_blank" rel="external">Evernote</a></h3>
<p><strong>必装</strong>，平时找到的技术文章，牛人的随笔都可以记录下来,也可以自己写学习笔记，搜索也十分迅速<br>唯一的不足是有国际版和大陆版两种账号，而且不共享，我就吃了亏，国内的笔记没能同步过来。</p>
<p><img src="http://i.imgur.com/otbPVUim.png" alt="Imgur"></p>
<h3 id="Google_Driver"><a href="https://www.google.com/drive" target="_blank" rel="external">Google Driver</a></h3>
<p><strong>必装</strong>，平时分享文件，上传东西还在用qq群，U盘么？那你就太老土了，在这个资料日益珍贵的年代，我无法想象如果我的所有资料都没了，让我重头起家，那会是多么浩大的一个工程。<br>幸好现在有了许多免费的云存储服务，google driver免费的15G空间足够平时使用了，配合github基本上资料不会丢，最关键的是分享或者共同协作一些文章，会相当方便<br>同类：Dropbox</p>
<h3 id="1Password_5"><a href="https://agilebits.com/onepassword" target="_blank" rel="external">1Password 5</a></h3>
<p><strong>必装</strong>，最方便高效的密码管理器，这年头安全是多么重要，大家可不要像大表姐一样被泄露了艳照，嘿嘿。<br>这个软件有一个主密码，对每个不同的网站生成不同的密码进行管理，而且会自动填写页面的密码可以通过icloud或者Dropbox同步</p>
<p><img src="http://i.imgur.com/ncFptrU.png" alt="Imgur"></p>
<h3 id="Moom"><a href="http://manytricks.com/moom/" target="_blank" rel="external">Moom</a></h3>
<p><strong>推荐</strong>，窗口移动工具，对于程序来说，同时开几个窗口那是家常便饭，一个一个移动真是太麻烦了，好在这个软件完美的帮我们解决了问题</p>
<h3 id="Mou/MacDown"><a href="http://25.io/mou/" target="_blank" rel="external">Mou</a>/<a href="http://macdown.uranusjr.com/" target="_blank" rel="external">MacDown</a></h3>
<p><strong>推荐</strong>，可视化的md编辑器，其实用哪个都行，但是md没有统一的标准，所以不同编辑器的效果有可能不一样。</p>
<p><img src="http://i.imgur.com/FejLedt.png" alt="Imgur"></p>
<h3 id="Pocket"><a href="https://getpocket.com/" target="_blank" rel="external">Pocket</a></h3>
<p><strong>推荐</strong>，readerlater工具，保存网站文章或者微博文章，等有时间了就阅读一下，而且这个软件对移动端的支持非常好</p>
<h3 id="AppCleaner"><a href="http://www.freemacsoft.net/appcleaner/" target="_blank" rel="external">AppCleaner</a></h3>
<p><strong>推荐</strong>，清理软件的程序</p>
<h3 id="iStat_Menus"><a href="http://bjango.com/mac/istatmenus/" target="_blank" rel="external">iStat Menus</a></h3>
<p><strong>推荐</strong>，检测自己的电脑的各个参数，对于打游戏的同学，可以手动调风扇转速很方便</p>
<h2 id="开发">开发</h2>
<h3 id="Dash"><a href="http://kapeli.com/dash" target="_blank" rel="external">Dash</a></h3>
<p><strong>必装</strong>，查文档的工具，非常好用节省时间，配合alfred能快速查找api</p>
<p><img src="http://i.imgur.com/NHFJF6m.png" alt="Imgur"></p>
<h3 id="Homebrew"><a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a></h3>
<p><strong>必装</strong>，Mac下的包管理器，装东西卸载东西都很方便，一个命令 brew install就完事了，要卸载就brew uninstall</p>
<h3 id="zsh">zsh</h3>
<p><strong>必装</strong>，虽然Mac原装的bash已经很好用了，但是zsh的功能更加丰富，而且全面兼容bash，利用<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">oh-my-zsh</a>一键安装很方便，而且提供上百种插件，例如自带的git能alias相当多的git命令，还有神器z或者autojump，能记住cd进入过的目录，下一次进入的时候，只要z然后输出目录关键字就能到大，再也不用输出一串超级长的cd命令了。</p>
<h3 id="TotalTerminal"><a href="http://totalterminal.binaryage.com/" target="_blank" rel="external">TotalTerminal</a></h3>
<p><strong>推荐</strong>，一款不错的终端，可以通过快捷键下拉，我的时command+command，还提供标签和查询功能，比原生的terminal强大不少。</p>
<h3 id="CodeRunner"><a href="https://coderunnerapp.com/" target="_blank" rel="external">CodeRunner</a></h3>
<p><strong>推荐</strong>，测试一些小代码专用，比如想试试这个函数对不对啊，这个类怎么用啊都可以放进这个软件里跑，各种语言基本都支持。</p>
<p><img src="http://i.imgur.com/PgT7U7um.png" alt="Imgur"></p>
<h3 id="Hexo"><a href="http://hexo.io/" target="_blank" rel="external">Hexo</a></h3>
<p><strong>推荐</strong>，博客利器，关键我比较喜欢用md写东西，所以非常方便，原本用wordpress，但是感觉太繁重了，hexo比较轻量级，配置也方便。</p>
<h2 id="Editor—-VIM">Editor—-VIM</h2>
<p>我个人只用vim，所以就说一些插件的经验，emacs党可以跳过</p>
<h3 id="pathogen"><a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="external">pathogen</a></h3>
<p>插件管理器，很方便的管理自己的插件<br>同类：vundle</p>
<h3 id="nerdtree"><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="external">nerdtree</a></h3>
<p>编辑vim时可以树形查看自己的目录结构，分屏操作</p>
<h3 id="YouCompleteMe"><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">YouCompleteMe</a></h3>
<p>神级代码补全软件，google员工的作品，配置有点麻烦，但是相当好用</p>
<h3 id="ultisnips&amp;&amp;vim-snippets"><a href="https://github.com/SirVer/ultisnips" target="_blank" rel="external">ultisnips</a>&amp;&amp;vim-snippets</h3>
<p>定义了一些代码块，避免了很多重复劳动</p>
<p><img src="http://i.imgur.com/hqlcWNs.png" alt="Imgur"></p>
<h2 id="其他">其他</h2>
<h3 id="Popcorn-Time"><a href="https://popcorntime.io/" target="_blank" rel="external">Popcorn-Time</a></h3>
<p>老美也用的在线P2P高清1080P的电影的电视剧</p>
<h3 id="uTorrent"><a href="http://www.utorrent.com/" target="_blank" rel="external">uTorrent</a></h3>
<p>迅雷在美国封杀了，所以用这个，在海盗湾下载东西十分快，尤其是那些<strong>你懂得</strong>种子。</p>
<h3 id="Steam"><a href="http://store.steampowered.com/" target="_blank" rel="external">Steam</a></h3>
<p>已经有很多游戏支持Mac平台了，平时在上面玩dota2和csgo。</p>
<h2 id="后记">后记</h2>
<p>这几天联合<a href="http://yanguango.com" target="_blank" rel="external">yanguango</a>和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>对一个windows用户进行了深刻的宣传，像苍蝇一样盯着他说Mac有多好，多牛逼。。。。。最后这个同志在我们不厌其烦的劝导下，上纽约中央车站拿下了一台mac，哈哈哈哈哈哈。。。。</p>
<p><img src="http://i.imgur.com/nxFvrCa.png" alt="Imgur"></p>
<p>以上所有的软件均为正版，也请大家尊重程序员的劳动，支持正版！</p>
<p>今天正好下雪停课，本着共享开源的精神，写下了这些东西分享给大家，希望有帮助，如果还有哪些Mac下的神器我没发现，也请大家通过屏幕下方的联系方式告诉我，我也会不断更新，谢谢！</p>
<p>作者:lin<br>邮箱:liulin.jacob@gmail.com<br><a href="http://weibo.com/1939168341" target="_blank" rel="external">新浪微博</a><br><a href="https://github.com/liulin2012" target="_blank" rel="external">github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>用Mac也1年多了，前半年基本用来打游戏看电影了，由于mac基于unix而来，游戏比较少，好在我只玩dota2，所以对我来说，mac的娱乐性很足。</p>
<p>真正让我感觉离不开Mac的，是我这半年来的学习和开发，在<a href="http://yanguango.com" target="_blank" rel="external">yanguango</a>和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>的帮助下，对mac可以说有了全新的认识，也对linux编程，shell，vim有了更深入的了解。</p>
<h2 id="为什么选择Mac？">为什么选择Mac？</h2>
<p>对于一个程序猿来说，<strong>效率</strong>永远是第一位的，这不仅体现在学习的效率，还有工作编码的效率。在时间平等的情况下，如果才能有更多的<strong>产出</strong>，这一直是程序员所要思考进步的，如何节省<strong>时间</strong>来换取更高的产出呢?答案是——<a href="http://daily.zhihu.com/story/3387025" target="_blank" rel="external">能花钱的，就不要花时间</a></p>
<p>也许有的人说，Mac太贵，对一个还在上学的学生来说压力太大，确实，2000刀的一台mac对于学生党来说是不小的开支，但是如果你有能力，我<strong>极力</strong>劝你先入手一台mac，为什么呢？——<a href="http://www.cnblogs.com/chijianqiang/p/mmac.html" target="_blank" rel="external">先有 Mac 还是先有银元？</a></p>
<p>那有了Mac如何提高效率了，可以看看这篇文章——<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=206041450&amp;idx=1&amp;sn=3982c8cc45d7c47f0fbc19fe8371490f&amp;scene=0#rd" target="_blank" rel="external">程序员效率指南</a></p>
<p><strong>工欲善其事，必选利其器</strong></p>
<p>下面是我自己的一些经验分享，也是我最常使用的一些软件。<br>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="Mac" scheme="http://yoursite.com/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The prime contest]]></title>
    <link href="http://yoursite.com/2015/02/17/The-prime-contest/"/>
    <id>http://yoursite.com/2015/02/17/The-prime-contest/</id>
    <published>2015-02-17T06:37:34.000Z</published>
    <updated>2015-03-29T21:37:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Overview">Overview</h2>
<p>sum the primes from a to b, inclusive, a &lt; b &lt;= $10^{14}$.<br>Measure how long it takes your algorithm to sum the primes from 1 to $10^9$.<br>Determine the complexity of your algorithm and calculate how long it would take to sum for a=1, b = $10^{12}$.</p>
<h2 id="Algorithm">Algorithm</h2>
<p>I have used the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="external">Sieve_of_Eratosthenes </a>algorithm to delete the primes from the vector.<br><a id="more"></a></p>
<h2 id="Multi-thread">Multi-thread</h2>
<p>I have used the multithread technology to speed up the program.I have test some data.You can change the thread number to check the answer and find the best thread number in this experiment.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Data</th>
<th style="text-align:center">Thread number</th>
<th style="text-align:center">Execution time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1~$10^9$</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">0.6 Sec</td>
</tr>
<tr>
<td style="text-align:center">1~$10^{10}$</td>
<td style="text-align:center">5000</td>
<td style="text-align:center">6.8 Sec</td>
</tr>
<tr>
<td style="text-align:center">1~$10^{11}$</td>
<td style="text-align:center">10000</td>
<td style="text-align:center">90 Sec</td>
</tr>
</tbody>
</table>
<p><img src="http://i.imgur.com/f8dSURel.png" alt=""></p>
<p><img src="http://i.imgur.com/0NN7rXal.png" alt=""></p>
<p><img src="http://i.imgur.com/oNFQTwTl.png" alt=""></p>
<h2 id="Compiler_optimize">Compiler optimize</h2>
<pre><code><span class="comment">clang</span><span class="literal">+</span><span class="literal">+</span> <span class="literal">-</span><span class="comment">std=c</span><span class="literal">+</span><span class="literal">+</span><span class="comment">11</span>  <span class="literal">-</span><span class="comment">O2</span> <span class="comment">main</span><span class="string">.</span><span class="comment">cpp</span>
</code></pre><p>I have use the <code>-O2</code> to optimize the compiler and then</p>
<pre><code>./a.<span class="keyword">out</span>
</code></pre><p>This trick can <a href="https://msdn.microsoft.com/en-us/library/8f8h5cxt.aspx" target="_blank" rel="external">Maximize Speed</a> when compile the C++ code.</p>
<h2 id="Analyze">Analyze</h2>
<p>I have research on on the internet</p>
<blockquote>
<p>The bit complexity of the algorithm is O(n (log n) (log log n)) bit operations with a memory requirement of O(n).</p>
</blockquote>
<p>My result show above when I test the data $10^{9}$,$10^{10}$,$10^{11}$.Due to the algorithm complexity,I calculate the $10^{12}$ need to use 17 minute.</p>
<h2 id="Final">Final</h2>
<p>If you have any question,be free to contact me.Thank you!</p>
<ul>
<li>Author:lin</li>
<li>Email:liulin.jacob@gmail.com</li>
<li>Code Address:<a href="https://github.com/liulin2012/CPE593/blob/master/HW1b/main.cpp" target="_blank" rel="external">The prime contest</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Overview">Overview</h2>
<p>sum the primes from a to b, inclusive, a &lt; b &lt;= $10^{14}$.<br>Measure how long it takes your algorithm to sum the primes from 1 to $10^9$.<br>Determine the complexity of your algorithm and calculate how long it would take to sum for a=1, b = $10^{12}$.</p>
<h2 id="Algorithm">Algorithm</h2>
<p>I have used the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="external">Sieve_of_Eratosthenes </a>algorithm to delete the primes from the vector.<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="multithread" scheme="http://yoursite.com/tags/multithread/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Realize DHT Network through RESTful]]></title>
    <link href="http://yoursite.com/2014/11/07/realize-dht-network-through-restful/"/>
    <id>http://yoursite.com/2014/11/07/realize-dht-network-through-restful/</id>
    <published>2014-11-08T04:53:34.000Z</published>
    <updated>2015-03-06T19:27:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1-DHT_Network">1.DHT Network</h1>
<blockquote>
<p>DHT(<a href="http://en.wikipedia.org/wiki/Distributed_hash_table" title="DHT" target="_blank" rel="external">Distributed Hash Tables</a>)is a class of a decentralized <a href="http://en.wikipedia.org/wiki/Distributed_computing" title="Distributed computing" target="_blank" rel="external">distributed system</a> that provides a lookup service similar to a <a href="http://en.wikipedia.org/wiki/Hash_table" title="Hash table" target="_blank" rel="external">hash table</a>; (<em>key</em>, <em>value</em>) pairs are stored in a DHT, and any participating <a href="http://en.wikipedia.org/wiki/Node_(networking" target="_blank" rel="external">node</a> “Node (networking)”) can efficiently retrieve the value associated with a given key. Responsibility for maintaining the mapping from keys to values is distributed among the nodes, in such a way that a change in the set of participants causes a minimal amount of disruption. This allows a DHT to scale to extremely large numbers of nodes and to handle continual node arrivals, departures, and failures.</p>
</blockquote>
<p>The key idea for the DHT network is utilize the pair(key,value) to  store and retrieve the data in distributed system.<br><a id="more"></a></p>
<p>1:Every resource has a unique<strong> pair(key,value)</strong> to distinguish.</p>
<p>2:System will use hash function to process every key,and use the result to determine where this resource should be stored in the DHT network.</p>
<p>3:When a user want to get the resource,use the same algorithm to hash the key and get the destination of the resource.</p>
<p>Maybe you didn’t know what I am saying now,but I will use the real model to realize this algorithm and then you will know the key idea about the DHT.After used this algorithm,the DHT network has a new key feature different from other distributed system like the GFS(<a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/10/The-Google-File-System.pdf" target="_blank" rel="external">The Google File System</a>).Every node(a computer in the DHT network) is both client and server,to responsible for a small route and storage in its area.So DHT don’t need a “super computer” to know everything in the system.This is why DHT is called <strong>decentralized distributed system.</strong></p>
<blockquote>
<p>Tips:In the GFS,system need to use a <strong>master</strong> to “control” everything.It needs to know all the information in the distributed system.Obviously,The <strong>master </strong>is the bottleneck in this system,but google has done a lot of optimize in the system,so it is very useful,more information about GFS,you can see the paper in the reference below.<br>&nbsp;</p>
</blockquote>
<p>In that case,DHT can be very scalability because it isn’t limited from the central control like the master in the GFS.So it is beneficial to store the huge amount of data in a distributed network.The famous application is the <a href="http://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="external">NoSQL</a> database such as <strong><a href="http://en.wikipedia.org/wiki/Apache_Cassandra" target="_blank" rel="external">Cassandra</a> </strong>by facebook and <a href="http://en.wikipedia.org/wiki/Dynamo_(storage_system" target="_blank" rel="external">Dynamo</a>) by Amazon.</p>
<p>There are a lot of different way to realize the DHT algorithm like Ring, Tree, Hypercube, Skip List, BuVerfly Network, …I have used the <a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer" target="_blank" rel="external">chord</a>) to do that because it is easy to explain and use.</p>
<p><img src="/images/c875063ffe4b73b15aa8d6d3e19c213c9b56437e.png" alt="45b48d324a1089fc21efa&amp;690"></p>
<p><strong>figure 1</strong></p>
<p>Step to realize the algorithm:</p>
<p>1:Every computer in the DHT network is a <strong>node</strong> which means it is responsible for store the data and route.In the figure1,each computer is represented as N1,N8,N14,N21……</p>
<p>2:Every resource is a <strong>pair(key,value).</strong>The resource can be everything such as the movie,music or the data in the application.The resource name will be hashed into a key and stored in a node.The resource is represented as K10,K24,K30…..The number is the key number of the resource.</p>
<p>3:The <strong>rule</strong> to store the resource in the computer(node) is that the resource is stored in the node which node number is <strong>bigger</strong> than resource key and the <strong>closest</strong> to that resource.For instance,the K10 need to store in N14 because N14 is bigger than 10 and N14 is the closest node to the K10.So K30 and K24 is stored in N32.In that case,once a new resource want to be stored in the DHT network,the resource name will be hashed into a key value and then use this value to determine where the resource should be stored.(This point is very <strong>important</strong> to understand the DHT network,if you can’t even understand what I am saying now,back to the step1 again.)</p>
<p><a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/11/45b48d324a1089fd1ebbdamp690.png" target="_blank" rel="external"><img src="/images/42aba3ce704bd922cb35b2ffa6cdf00647d7fdbe.png" alt="45b48d324a1089fd1ebbd&amp;690"></a></p>
<p>&nbsp;</p>
<p><strong>figure 2</strong></p>
<p>Now,you should know how to store a resource in a node.But how to realize it?</p>
<p><strong>rule</strong>:every node has its own finger table to route.FINGERN(i) = min {IDN2 | IDn2 ≥ IDn + 2^i (mod M)}</p>
<p>In the figure 2:</p>
<p>N8+1=N9,N9 belong to N14</p>
<p>N8+2=N10,N10 belong to N14</p>
<p>N8+8=N16,N16 belong to N21</p>
<p>For example,if one resource enter in the system and the key value is 22,so it is called K22.Once K22 enter in the system from the N8 and then retrieve the finger table,N8+8 is 16,N8+16 is 24.The K22 is between 16 and 24.So the K22 go to the 16 which is N21.And then use the N21 finger table to retrieve.</p>
<p>&nbsp;</p>
<p><a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/11/45b48d324a1089fffe1beamp690.png" target="_blank" rel="external"><img src="/images/59ebda1755c8399caa8871fe3b0f31c04fc245a8.png" alt="45b48d324a1089fffe1be&amp;690"></a></p>
<p>&nbsp;</p>
<p><strong>figure 3 </strong></p>
<p>If the key value is bigger than any number of the finger table,use the biggest one.Figure 3 show this condition.<a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/11/Screen-Shot-2014-11-08-at-01.52.25.png" target="_blank" rel="external"><img src="/images/3bef9e86b26304a922e1223c6d98e17b7b8ece1d.png" alt="Screen Shot 2014-11-08 at 01.52.25"></a></p>
<p><strong>figure 4</strong></p>
<p>Figure 4 show the detail about the route process.</p>
<blockquote>
<p>So,what is the <strong>algorithm complexity</strong>?It is same to the finger table size!With high probability, Chord contacts O(log N) nodes to find a successor in an N-node network.</p>
</blockquote>
<h1 id="2-RESTful">2.RESTful</h1>
<p>The RESTful(<a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external"><strong>Representational state transfer</strong></a>) is used to connect each node.It is easy to use because it only use the <strong>HTTP command</strong> which is familiar to us.Every node has RESTful client and server,so they can send the request to another and get the response.</p>
<p>In the client side,the client send the <strong>http request</strong> to the server side and get a Response from the server.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Response <span class="title">getRequest</span>(URI uri) {</div><div class="line">		<span class="keyword">try</span> {</div><div class="line">			Response cr = client.target(uri)</div><div class="line">					.request(MediaType.APPLICATION_XML_TYPE)</div><div class="line">					.header(Time.TIME_STAMP, Time.advanceTime())</div><div class="line">					.get();</div><div class="line">			processResponseTimestamp(cr);</div><div class="line">			<span class="keyword">return</span> cr;</div><div class="line">		} <span class="keyword">catch</span> (Exception e) {</div><div class="line">			error(&quot;Exception during GET request: &quot; + e);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line"><span class="keyword">public</span> String[] <span class="title">get</span>(NodeInfo n, String k) <span class="keyword">throws</span> Failed{</div><div class="line">		UriBuilder ub = UriBuilder.fromUri(n.addr);</div><div class="line">		URI getPath = ub.queryParam(&quot;key&quot;, k).build();</div><div class="line">		info(&quot;client get(&quot;+getPath+&quot;)&quot;);</div><div class="line">		Response response=getRequest(getPath);</div><div class="line">		<span class="keyword">if</span> (response == <span class="keyword">null</span> || response.getStatus() &gt;= <span class="number">300</span>) {</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> DHTBase.Failed(&quot;GET ?key=&quot;+k+&quot;addr=&quot;+n.addr);</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> response.readEntity(tableRowType).getValue().vals;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>In the server side,you can use the annotation to identify the path and response the request.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@GET</span></div><div class="line"><span class="annotation">@Path</span>(&amp;quot;info&amp;quot;)</div><div class="line"><span class="annotation">@Produces</span>(&amp;quot;application/xml&amp;quot;)</div><div class="line"><span class="keyword">public</span> Response <span class="title">getNodeInfoXML</span>() {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> NodeService(headers, uriInfo).getNodeInfo();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>The more detail about the RESTful you can see the wiki and the paper in the UCI.</p>
<h1 id="3-Final">3.Final</h1>
<p>This is my first time to write a English technology passage,so if you have found there are some errors or someplace you didn’t understand yet,please do not hesitate to contact me through the email <strong>liulin.jacob@gmail.com </strong>or leave a message below the passage.I am glad to receive your email.If you have some comment about my blog,I am appreciated to learn from you.</p>
<p>Thank you,have fun</p>
<p>lin</p>
<p>liulin.jacob@gmail.com</p>
<p>&nbsp;</p>
<p><strong>References:</strong></p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Distributed_hash_table" title="DHT" target="_blank" rel="external">Distributed Hash Tables</a></li>
<li><a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer" target="_blank" rel="external">chord</a>)</li>
<li><a href="http://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="external">NoSQL</a></li>
<li><a href="http://en.wikipedia.org/wiki/Apache_Cassandra" target="_blank" rel="external">Cassandra</a></li>
<li><a href="http://en.wikipedia.org/wiki/Dynamo_(storage_system" target="_blank" rel="external">Dynamo</a>)</li>
<li><a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/10/The-Google-File-System.pdf" target="_blank" rel="external">The Google File System</a></li>
<li><a href="http://blog.csdn.net/opennaive/article/details/7483523" target="_blank" rel="external">谷歌技术”三宝”之谷歌文件系统</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_45b48d320100q6u7.html" target="_blank" rel="external">结构化P2P网络——DHT网络原理</a></li>
<li><a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external">Representational state transfer</a></li>
<li><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="external">Representational State Transfer (REST)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计指南</a></li>
</ul>
<h3 id="Related_articles_across_the_web">Related articles across the web</h3>
<ul>
<li><a href="http://blog.libtorrent.org/2014/11/dht-routing-table-maintenance/" target="_blank" rel="external"><img src="/images/c6b6bb93117a03074522e3292ed420c48fa495b8.jpg" alt=""></a><a href="http://blog.libtorrent.org/2014/11/dht-routing-table-maintenance/" target="_blank" rel="external">DHT routing table maintenance</a></li>
<li><a href="http://themindstorms.blogspot.com/2014/11/nosql-nosql-databases-hadoop-big-data.html" target="_blank" rel="external"><img src="/images/ac855e72b11d34da1bb518f43d6e000380c53f47.jpg" alt=""></a><a href="http://themindstorms.blogspot.com/2014/11/nosql-nosql-databases-hadoop-big-data.html" target="_blank" rel="external">NoSQL: NoSQL databases, Hadoop, Big Data: Pinned tabs Nov.3rd</a></li>
<li><a href="http://www.databasetube.com/nosql/dynamic-dynamos-comparing-riak-and-cassandra/" target="_blank" rel="external"><img src="/images/5a14a111c81e9492df286ed237beb7c84978d2ef.jpg" alt=""></a><a href="http://www.databasetube.com/nosql/dynamic-dynamos-comparing-riak-and-cassandra/" target="_blank" rel="external">Dynamic Dynamos: Comparing Riak and Cassandra</a></li>
<li><a href="http://www.hakkalabs.co/articles/eventbrite-recommendation-engine-apache-cassandra-2/" target="_blank" rel="external"><img src="/images/1772745eefe96420fd3a003d9d75fd46980dbba9.jpg" alt=""></a><a href="http://www.hakkalabs.co/articles/eventbrite-recommendation-engine-apache-cassandra-2/" target="_blank" rel="external">Eventbrite Recommendation Engine on Apache Cassandra</a></li>
<li><a href="http://cloudcelebrity.wordpress.com/2014/10/20/the-present-and-future-of-hadoop-from-its-creator-doug-cutting/" target="_blank" rel="external"><img src="/images/082126dfc9c351850e17320faab33fc5b1bd1cfb.jpg" alt=""></a><a href="http://cloudcelebrity.wordpress.com/2014/10/20/the-present-and-future-of-hadoop-from-its-creator-doug-cutting/" target="_blank" rel="external">The present and future of Hadoop from its creator Doug Cutting</a></li>
<li><a href="http://www.programmableweb.com/news/opendirect-api-standardizes-digital-ad-trading/elsewhere-web/2014/11/06" target="_blank" rel="external"><img src="/images/be783f37a738995347c6672aa3ee7cf3558d1834.jpg" alt=""></a><a href="http://www.programmableweb.com/news/opendirect-api-standardizes-digital-ad-trading/elsewhere-web/2014/11/06" target="_blank" rel="external">OpenDirect API Standardizes Digital Ad Trading</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-DHT_Network">1.DHT Network</h1>
<blockquote>
<p>DHT(<a href="http://en.wikipedia.org/wiki/Distributed_hash_table" title="DHT" target="_blank" rel="external">Distributed Hash Tables</a>)is a class of a decentralized <a href="http://en.wikipedia.org/wiki/Distributed_computing" title="Distributed computing" target="_blank" rel="external">distributed system</a> that provides a lookup service similar to a <a href="http://en.wikipedia.org/wiki/Hash_table" title="Hash table" target="_blank" rel="external">hash table</a>; (<em>key</em>, <em>value</em>) pairs are stored in a DHT, and any participating <a href="http://en.wikipedia.org/wiki/Node_(networking" target="_blank" rel="external">node</a> “Node (networking)”) can efficiently retrieve the value associated with a given key. Responsibility for maintaining the mapping from keys to values is distributed among the nodes, in such a way that a change in the set of participants causes a minimal amount of disruption. This allows a DHT to scale to extremely large numbers of nodes and to handle continual node arrivals, departures, and failures.</p>
</blockquote>
<p>The key idea for the DHT network is utilize the pair(key,value) to  store and retrieve the data in distributed system.<br>]]>
    
    </summary>
    
      <category term="DHT" scheme="http://yoursite.com/tags/DHT/"/>
    
      <category term="RESTful" scheme="http://yoursite.com/tags/RESTful/"/>
    
      <category term="Cloud Computing" scheme="http://yoursite.com/categories/Cloud-Computing/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello,Everyone]]></title>
    <link href="http://yoursite.com/2014/10/09/helloeveryone/"/>
    <id>http://yoursite.com/2014/10/09/helloeveryone/</id>
    <published>2014-10-10T00:30:40.000Z</published>
    <updated>2015-02-17T04:46:43.000Z</updated>
    <content type="html"><![CDATA[<p>Hello,everyone,I am lin liu,come from China My major is computer science and I am studying in America now.</p>
<p>Soccer and Dota2 are my favorite sports.Besides that,I am also fond of studying the computer science technology ,especially the cloud computing and algorithm.</p>
<p>This blog will be updated in an indefinite schedule,including the technology passage,studying experience,life record and so on.The passage will be written in English,sometimes both in English and Chinese.Due to my poor English,maybe I will write some sentences you can’t understand.Please calm down,do not fuck me.I am learning. lol</p>
<p>Finally,thank you for your coming.Good luck,have fun~~</p>
<p>&nbsp;</p>
<p>大家好，我是刘霖，来自中国，CS专业苦逼码农一枚，现在在大美帝专心读书。</p>
<p>平时酷爱踢足球打Dota2，没事钻研一下技术，现在主要学习云计算以及算法方面的知识,</p>
<p>本博客不定时更新文章，包括技术文章，学习心得，生活记录等等，经常拖稿和跳票，一般写英文的，有时候也会中英文双语，看心情。。。嘿嘿。。。由于英语水平不过关，经常会出现chiglish的情况，大家不要喷我，我也在慢慢学习之中。</p>
<p>最后谢谢大家来到我的博客，Have fun~~</p>
<p>&nbsp;</p>
<p>Lin</p>
<p>liulin.jacob@gmail.com</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Hello,everyone,I am lin liu,come from China My major is computer science and I am studying in America now.</p>
<p>Soccer and Dota2 are my]]>
    </summary>
    
      <category term="Daily life" scheme="http://yoursite.com/categories/Daily-life/"/>
    
  </entry>
  
</feed>
