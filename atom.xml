<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Lin]]></title>
  <subtitle><![CDATA[More code , Have fun]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-04-05T02:16:36.415Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[lin liu]]></name>
    <email><![CDATA[liulin.jacob@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[My TCP/IP Notes]]></title>
    <link href="http://yoursite.com/2015/04/04/My-TCP-IP-Notes/"/>
    <id>http://yoursite.com/2015/04/04/My-TCP-IP-Notes/</id>
    <published>2015-04-05T02:09:27.000Z</published>
    <updated>2015-04-05T02:16:12.000Z</updated>
    <content type="html"><![CDATA[<h2 id="TCP/IP_详解(卷1:协议)">TCP/IP 详解(卷1:协议)</h2>
<h3 id="第一章:概述">第一章:概述</h3>
<p>tcp/ip 四层协议:</p>
<ul>
<li>链路层：设备驱动程序及接口卡</li>
<li>网络层：处理分组在网络中的活动</li>
<li>运输层：为两台主机上的应用程序提供端到端的通信</li>
<li>应用层：处理应用程序细节<a id="more"></a>
</li>
</ul>
<p>应用层用到End-to-end协议,端到端<br>网络层是Hop-by-hop协议,点到点</p>
<p>网络层IP是不可靠的服务，只是尽可能快地把分组从源节点送到目的节点，但是不保证可靠<br>TCP在不可靠的IP层上提供了可靠的运输层，使用了超时重传，发送和接收端到端的确认分组等机制</p>
<p>路由器:在IP层把网络连在一起</p>
<p>以太网数据帧的物理长度在46~1500字节之间</p>
<p><img src="http://i.imgur.com/yOTtMgW.png" alt=""></p>
<h3 id="第二章:链路层">第二章:链路层</h3>
<p>TCP/IP支持多种不同的链路层协议，取决于网络所使用的硬件，如以太网，IEEE，SLIP，PPP封装格式</p>
<p>loopback interface:127.0.0.1 localhost</p>
<p>最大传输单元MTU:1500和1492字节等，不同传输介质有不同的MTU<br>如果IP层有一个数据报要传，数据长度比链路层MTU大，那就要分片fragmentation<br>路径MTU:重要的不是两台主机所在的网络的MTU值，而是两台通信主机路径中最小MTU，被称为路径MTU<br>两台主机之间的路径MTU不一定是个常数，他取决于所选择的路由，选路也不一定是对称的，所以路径MTU在两个方向上不一定是一致的。</p>
<h4 id="2-7_环回接口">2.7 环回接口</h4>
<p>127.0.0.1 localhost</p>
<ul>
<li>传给环回地址的任何数据都作为ip输入</li>
<li>传给广播或多播地址的数据报复制一份传给环回接口，然后送到以太网</li>
<li>任何传给该主机ip地址的数据均送到环回接口</li>
</ul>
<p>环回接口可以被看做网络层下面的另一个链路层，网络层把一份数据报传给环回接口，就像传给其他链路层一样，只不过环回接口把它返回到ip的输入队列</p>
<h3 id="第三章:IP">第三章:IP</h3>
<h4 id="3-1_引言">3.1 引言</h4>
<p>不可靠(unreliable):不能保证IP数据报能成功地到达目的地<br>无连接(connectionless):不维护任何后续数据报的状态信息，每个数据报都是相互独立的，可以不按发送顺序接收，每个数据报独立地进行路由选择，可能选不同的路线。</p>
<h4 id="3-2_IP首部">3.2 IP首部</h4>
<p><img src="http://i.imgur.com/BXxEwJ3.png" alt=""></p>
<p>版本号:现在时4<br>首部长度:首部占32bit字的数目，不含选项时，普通IP数据报是5(4<em>5=20字节)，如果有选项，最大是60字节(4</em>15=60)<br>服务类型:TOS,代表最小时延，最大吞吐量，最高可靠性，最小费用，只有一个为1bit，全为0就是一般服务<br>总长度:整个ip数据报的长度，最大65534，但是大多数情况会分片。由于一些链路层要填充数据达到最小长度，所以总长度字段可以知道有多少是ip数据报的内容<br>表示字段:唯一标示主机发送的每一份数据报<br>TTL:设置了数据报可以经过的最多路由器数，每经过一个减1，到0时数据报被丢弃<br>协议字段:识别哪个协议向ip传送字段<br>首部检验和字段根据ip首部计算的检验和码，不对后面的数据进行计算<br>发送方计算检验和放入，接收方计算所有的，全为1时说明正确，不是全1时丢弃，但是不产生差错报文，由上层发现，每通过一个路由器ttl减1，检验和增加</p>
<h4 id="3-3_IP路由选择">3.3 IP路由选择</h4>
<p>路由表信息:</p>
<ul>
<li>目的ip地址</li>
<li>下一站路由器ip地址</li>
<li>标志</li>
<li>网络接口</li>
</ul>
<p>ip路游:</p>
<ul>
<li>搜索路由表，寻找目的ip地址完全匹配的表目，<strong>网络号和主机号</strong></li>
<li>寻找与网络号相匹配的表目，<strong>网络号</strong></li>
<li>使用默认表目</li>
</ul>
<p>关键:</p>
<ul>
<li>数据报中的ip地址始终不发生变化</li>
<li>每一次的链路层地址都不同，链路层地址指向下一站的链路层地址</li>
</ul>
<h4 id="3-4_子网寻址">3.4 子网寻址</h4>
<p>ip地址由网络号和主机号组成<br>主机号可以分为子网号和主机号<br>16bit的主机号，8bit子网号，8bit主机号，就有254个子网，每个子网有254主机</p>
<p>子网对外部路由器是隐藏内部网络组织的<br>使用子网的B类地址，可以缩小internet路由器的规模，对外的路由器是透明的，只需要一个路由器表，缩小了路由表的规模</p>
<p>子网对子网内部的路由器是不透明的</p>
<h4 id="3-5_子网掩码">3.5 子网掩码</h4>
<p>除了ip地址外，主机还需要知道多少比特用于子网号及多少比特用于主机号，所以需要子网掩码<br>子网掩码:值为1的比特留给网络号和子网号，为0的比特留给主机号</p>
<p>这样，给定了ip地址和子网掩码以后，主机就可以确定数据报的目的</p>
<ul>
<li>本子网上的主机</li>
<li>本网络中其他子网的主机</li>
<li>其他网络的主机</li>
</ul>
<p>知道ip地址，就知道他是否为a,b,c类，从ip地址高位得知，也就知道了网络号和子网号之间的分界线，通过子网掩码知道子网号和主机号的分界线</p>
<h4 id="3-6_特殊情况的ip地址">3.6 特殊情况的ip地址</h4>
<p>特殊源地址，环回地址，广播地址</p>
<h4 id="3-7_子网例子">3.7 子网例子</h4>
<p>变长子网:一个子网的网络使用多个子网掩码<br>11位子网中，前8位始终是13，后面3bit表示不同的子网，001表示以太网，010表示slip链路，对外来说只要知道13在哪里就行，对于内部的sun主机来说知道变长子网就行了</p>
<p><img src="http://i.imgur.com/G8Cludv.png" alt=""></p>
<h4 id="3-8_ifconfig命令">3.8 ifconfig命令</h4>
<p>tcpip对网络接口进行配置和查询的命令</p>
<h4 id="3-9_netstat命令">3.9 netstat命令</h4>
<p>netstat -in<br>提供系统上的接口信息</p>
<h3 id="第四章_ARP">第四章 ARP</h3>
<h4 id="4-1_引言">4.1 引言</h4>
<p>ARP为ip地址到对应的硬件地址之间提供了动态映射</p>
<h4 id="4-2_例子">4.2 例子</h4>
<p>网络接口有一个硬件地址，48bit的值<br>tcpip有自己的地址：32bit的ip地址<br>内核必须知道目的端的硬件地址才能发送数据<br>ARP的功能就是在32bit的ip地址和采用不同网络技术的硬件地址之间提供动态映射</p>
<p>ARP发送一份称为ARP请求的以太网数据帧给以太网上的每一个主机，这个过程称作广播</p>
<h4 id="4-3_ARP高速缓存">4.3 ARP高速缓存</h4>
<p><code>arp -a</code><br>每个主机上都有一个ARP高速缓存，每一项大概20分钟存活时间<br>48bit的以太网地址用6个十六进制来标示</p>
<h4 id="4-4_ARP的分组格式">4.4 ARP的分组格式</h4>
<p>电缆上的所有以太网接口都要接受广播的数据帧</p>
<h4 id="4-5_ARP例子">4.5 ARP例子</h4>
<p>ff:ff:ff:ff:ff:ff 是以太网广播，电缆上的每个以太网接口都要接受这个数据帧对它进行处理，以太网最小长度是60字节，ARP请求或者回答的数据帧都是42字节，所以每一帧都必须加入填充字符以达到以太网的最小长度要求，有一些书最小长度64字节，因为算了4字节的以太网帧尾</p>
<p>ARP request is broadcast，The ARP reply is sent directly to the requesting host; it is not broadcast.</p>
<p>请求不存在主机的ARP请求时，会超时，tcpdump命令输出的超时限制是29.5秒，大多数BSD实现把完成TCP连接请求的时间限制为75秒</p>
<p>直到ARP回答返回，tcp报文段才可以被发送，因为硬件地址这时候才知道</p>
<p>完整表项超时20分钟，不完整3分钟</p>
<h4 id="4-6_ARP代理">4.6 ARP代理</h4>
<p>如果ARP请求时从一个网络主机发往另一个网络的主机，那么连接这<strong>两个网络</strong>的路由器就可以回答该请求，这个过程称作委托ARP或者ARP代理(Proxy ARP)，路由器的功能相当于目的主机的代理</p>
<p>路由器识别出ip地址术语它的一个拨号主机，于是它把自己的以太网接口地址作为硬件地址来回答</p>
<h4 id="4-7_免费ARP">4.7 免费ARP</h4>
<p>主机发送ARP查询自己的ip地址</p>
<p>两个作用:</p>
<ul>
<li>一个主机可以通过它来确定另一个主机是否设置了相同的ip地址</li>
<li>如果发送免费arp的主机改变了硬件地址，那么这个额分组就可以使其他主机告诉缓存中的旧的硬件地址进行相应的更新<h4 id="4-8_ARP命令">4.8 ARP命令</h4>
<code>-a</code>显示<code>-d</code>删除<code>-s</code>增加</li>
</ul>
<h3 id="第六章_ICMP:internet控制报文协议">第六章 ICMP:internet控制报文协议</h3>
<h4 id="6-1_引言">6.1 引言</h4>
<p>ICMP传递差错报文和其他需要注意的信息<br>ICMP报文前四个字节是一样的，剩下的其他字节互不相同<br><img src="http://i.imgur.com/pP6SZBs.png" alt=""></p>
<h4 id="6-2_ICMP报文的类型">6.2 ICMP报文的类型</h4>
<p><img src="http://i.imgur.com/TZIED64.png" alt=""></p>
<h4 id="6-3_ICMP地址掩码请求与应答">6.3 ICMP地址掩码请求与应答</h4>
<p>请求报文进行广播，然后打印所有应答，广播会包括自己的环回地址</p>
<p>RFC规定，除非系统是地址掩码的授权代理，否则不能发送地址掩码应答，但是大多数主机收到请求时都发送一个应答，甚至还是错误的应答，有bug</p>
<h4 id="6-4_ICMP时间戳请求与应答">6.4 ICMP时间戳请求与应答</h4>
<p>请求允许系统向另一个系统查询当前的时间<br>difference减去RTT的一半，就是调整值</p>
<h4 id="6-5_ICMP端口不可达差错">6.5 ICMP端口不可达差错</h4>
<p>这是一种差错报文<br>UDP的规则之一，如果收到一份udp数据报而目的端口与某个正在使用的进程不相符合，那么udp返回一个icmp不可达报文，可以用TFTP强制生成一个端口不可达报文</p>
<p>差错报文，必须包括差错报文的数据报IP首部，还必须至少包括跟在ip首部后面的前8个字节</p>
<p>包含在udp和tcp首部中的内容是源端口号和目的端口号</p>
<p><img src="http://i.imgur.com/kaeSChm.png" alt=""></p>
<h3 id="第七章_ping程序">第七章 ping程序</h3>
<h4 id="引言">引言</h4>
<p>目的为了测试另一台主机是否可达，程序发送一份icmp回显请求报文给主机，并等待返回icmp回显应答</p>
<h4 id="7-2_ping程序">7.2 ping程序</h4>
<p>允许观察分组丢失，失序，重复</p>
<p>LAN输出:当前时间减去icmp报文中的时间，就是往返时间，ttl位于ip首部<br>第一个返回时间要大因为arp请求</p>
<p>wan输出:有可能丢失分组，或者有重复或者失序的分组</p>
<p>slip：比较慢</p>
<h4 id="7-3_ip记录路由选项">7.3 ip记录路由选项</h4>
<p>ping程序提供-R选项，提供记录路由的功能，记录经过的所有路由器的地址，但是ip首部只有有限的空间来存放ip地址，37个字节可以(60-20-3)，3个是rr选项，20个师首部，所以只能存放<strong>9个ip地址</strong><br>由于有限制，所以用Traceroute工具更好<br>始终把出口的ip地址加入清单中，然后把自己的入口ip地址也加入清单中</p>
<p><img src="http://i.imgur.com/gz0HlDE.png" alt=""></p>
<h3 id="第八章_Traceroute程序">第八章 Traceroute程序</h3>
<h4 id="8-1_引言">8.1 引言</h4>
<p>可以让我们看到ip数据报从一台主机传到另一台主机所经过的路由</p>
<h4 id="8-2_Traceroute操作">8.2 Traceroute操作</h4>
<p>为什么要取代ping -R</p>
<ul>
<li>不是所有路由器都支持记录路由选项，Traceroute不需要中间路由器具备任何特殊的功能</li>
<li>路由记录一般是单向的选项</li>
<li>ip首部留给选项的空间有限，不能存放太多的路径</li>
</ul>
<p>Traceroute利用ICMP报文和ip首部的TTL字段(生存周期)</p>
<p>每个处理数据报的路由器都需要把TTL的值减1或减去在路由器中停留的秒数</p>
<p>TTL字段的目的是为了防止数据报在选路时无休止的在网络中流动</p>
<p>当路由器收到一份ip数据报，如果TTL为0或1，那路由器不转发数据报，路由器丢弃数据报，并发给源机一份ICMP“超时”信息，Traceroute程序通过这份ICMP信息的ip报文知道路由器的ip地址</p>
<p>先发送TTL为1的，然后发2，以此类推</p>
<p>Traceroute程序发送一份UDP数据报给目的主机，但是选择了一个不可能的值作为UDP端口号(大于30000)，目的主机产生<strong>端口不可达错误</strong></p>
<p>Traceroute程序区别接受到的<strong>ICMP超时</strong>或者<strong>ICMP端口不可达</strong>，就能知道所有的信息</p>
<h4 id="8-3_局域网输出">8.3 局域网输出</h4>
<p>第一行</p>
<ul>
<li>目的主机名和ip地址</li>
<li>最大TTL值 hops max</li>
<li>字节数(20字节ip首部，8字节udp首部和用户数据)</li>
</ul>
<p>对于每个TTL值，发送三份数据报，每季收到一份ICMP报文，打印往返时间，5秒内没收到任意一份，就打一个星号<br>Traceroute给出的时总往返时间</p>
<p>注意</p>
<ul>
<li>不能保证现在的路由就是将来的路由，甚至两份连续的ip数据报都有可能采用不同的路由</li>
<li>不能保证icmp报文的路由鱼Traceroute程序发送的ucp数据报采用同一种路由，往返时间可能不能真正体现数据发出和返回的时间差</li>
<li>icmp报文中的信源ip地址是udp数据报到达的<strong>路由器接口</strong>的ip地址，而ping是<strong>发送接口地址</strong>，所以从A到B运行Traceroute和从B到A运行Traceroute所得到的结果是不同的</li>
<li>Traceroute程序获得是ip地址，所以给定ip地址的情况下，要做一个反向域名查看来获取域名</li>
</ul>
<h4 id="8-4_广域网输出">8.4 广域网输出</h4>
<p>同一个地点有时候时间会有很大的差别，不能区分是发出的数据报还是返回的icmp差错数据报被拦截</p>
<h4 id="8-5_ip源站选路选项">8.5 ip源站选路选项</h4>
<p>源站选路(source routing)的思想史由发送者制定路由</p>
<ul>
<li>严格的源站路由选择，发送端志明ip之举报所必须经过的确切路由，如果路由器发现源路由所指定的下一个路由器不在其直接连接的网络上，它返回一个“源站路由失败”的ICMP差错报文</li>
<li>宽松源站选择，发送端志明了一个数据报经过的ip地址清单，但是数据报在清单上指明的任意两个地址之间可以通过其他路由器</li>
</ul>
<p>源站路由，必须在发送ip数据报钱填充ip地址清单，数量小于9个</p>
<p>源站路由运行过程：</p>
<ul>
<li>发送主机从应用程序接受源站路由清单，将第一个表项去掉，将所有剩余的项左移1个位置，并将原理啊的目的地址作为清单的最后一个</li>
<li>每个处理数据报的路由器检查其是否为数据报的最终地址，不是的话就转发数据报</li>
<li>如果该路由器是最终目的，且指针不大于路径的长度<br><img src="http://i.imgur.com/H6JQIPR.png" alt=""></li>
</ul>
<p><code>-g</code>是宽松路由选战的选项<br>最多制定8个中间路由器，最后一个是目的主机<br>会丢失路由器，这些丢失的路由器可能发生了与宽松路由选战选项数据有关的程序问题，所以没有显示<br>有星号说明失败，5秒内没有应答</p>
<p><code>-G</code>严格路由选路<br>!S表明失败，失败时发送<strong>源站路由失败</strong>的差错报文</p>
<p> 可以通过宽松的源站选路来进行往返路由</p>
<h3 id="第九章_IP选路">第九章 IP选路</h3>
<h4 id="9-1_引言">9.1 引言</h4>
<p>主机必须配置成一个路由器，否则通过网络接口接收到的数据报，如果目的地址不是本机就会被丢弃</p>
<h4 id="9-2_路由原理">9.2 路由原理</h4>
<p>内核维护路由表，路由表包含的信息决定了ip层所做的所有决定</p>
<p>ip搜索路由表步骤：</p>
<ol>
<li>搜索主机地址</li>
<li>搜索网络地址</li>
<li>搜索默认表项</li>
</ol>
<p>ip执行选路机制，路由守护程序提供选路策略</p>
<p><code>netstate -rn</code>显示路由表，显示ip地址</p>
<p>flag：</p>
<ul>
<li>U 该路由可用</li>
<li>G 该路由是一个网关（路由器），没有设置该标志说明目的地是直接相连的</li>
<li>H 是一个主机</li>
<li>D 该路由是由重定向报文创建</li>
<li>M 路由已经重定向报文修改</li>
</ul>
<p>G:区分间接路由和直接路由，对于直接路由不设置标志G<br>直接路由：目的地端的ip地址+链路层地址<br>间接路由：最终目的地的ip地址+下一站路由器的链路层地址</p>
<p>H:目的地址是一个完整的主机地址<br>没有设置说明是一个网络地址<br>为了某个ip搜索路由表时，主机地址项必须完全与目的地址匹配，而网络地址只西药匹配目的地址的网络号和子网号就ok了</p>
<p>refs:正在使用路由的活动进程个数<br>use:通过该路由发送的分组数<br>interface:本地接口</p>
<p>初始化路由<br>初始化一个接口时，创建直接路由<br>对于点对点链路和环回接口，路由到达主机，H标志<br>对于广播接口，以太网等，路由是网络<br><code>route</code>命令增加路由表的表项</p>
<p>复杂的路由表:<br>有可能有多个接口<br>netstate为直接路由打印出来的网关地址就是本地接口所用的ip地址</p>
<p>没有目的的路由<br>没有默认项和匹配项<br>本机产生:给发送该数据报的应用程序返回一个差错，<strong>主机不可达差错</strong>或者<strong>网络不可达差错</strong><br>如果是转发数据报，给原始发送端一份ICMP主机不可达的差错报文</p>
<h4 id="9-3_ICMP主机与网络不可达差错">9.3 ICMP主机与网络不可达差错</h4>
<p>返回主机不可达的回显请求报文</p>
<p>顶层选路域，有可能没有默认项，所以会返回不可达的回显请求报文</p>
<h4 id="9-5_ICMP重定向差错">9.5 ICMP重定向差错</h4>
<p>当ip数据报应该被发送到另外一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给ip数据报的发送端</p>
<p><img src="http://i.imgur.com/vDFWdlK.png" alt=""></p>
<p>重定向报文标志位D</p>
<h4 id="9-6_ICMP路由器发现报文">9.6 ICMP路由器发现报文</h4>
<p>初始化路由表的方法:</p>
<ul>
<li>配置文件中制定静态路由，经常用来设置默认路由</li>
<li>利用ICMP路由器通告和请求报文<br>主机在引导之后广播或者多播传送一份路由器请求报文，一台或多台路由器响应一份路由器通告报文。<br>路由器定期地广播或多播传送他们的路由器通告报文，允许每个监听的主机相应更新路由表</li>
</ul>
<p>路由器操作</p>
<ul>
<li>路由器启动时，广播或者多播接口上发送通告报文，不定期随机发送，450到600秒，生命周期30分钟</li>
<li>路由器关闭时，发送最后一份通告报文，生命周期为0</li>
<li>路由器监听来自主机的请求报文，发送路由器通告报文回应</li>
<li>多台路由器，系统管理员来设置路由器的设置优先级别</li>
</ul>
<p>主机操作</p>
<ul>
<li>引导期间发送三份路由器请求报文，收到一份有效的就停止</li>
<li>监听来自相邻路由器的请求报文</li>
</ul>
<h3 id="第十章_动态选路协议">第十章 动态选路协议</h3>
<h4 id="10-1_引言">10.1 引言</h4>
<p>静态选路：</p>
<ul>
<li>配置接口时，默认方式生成路由表项</li>
<li>通过route命令</li>
<li>通过ICMP重定向生成表项<br>限制：</li>
</ul>
<ol>
<li>网络很小</li>
<li>与其他网络知有单个连接点</li>
<li>没有多余路由时可行</li>
</ol>
<p>如果3个限制不能全部满足，通常用动态路由</p>
<ul>
<li>RIP(routing information protocal)</li>
<li>OSPF</li>
<li>BGP</li>
<li>无分类域间选路的新的选路技术</li>
</ul>
<h4 id="10-2_动态选路">10.2 动态选路</h4>
<p>相邻路由器进行通信，告知对方每个路由器所在网络，就是动态选路，有一个路由守护程序维护routing daemon</p>
<p>当路由随时间变化，路由是由路由守护程序进行增加或者删除，而不是来自于引导程序的route命令<br>路由守护程序有选路策略，维护路由表</p>
<p>internet以自治系统组织(AS,Autonomous system)</p>
<p>每个自治系统可以选择该自治系统中各个路由器之间的选路协议</p>
<ul>
<li>内部网关协议IGP(Interior Gateway protocol)</li>
<li>域内选路协议(intradomain routing protocol)</li>
<li>常用的时RIP</li>
</ul>
<p>外部网关协议</p>
<ul>
<li>EGP</li>
<li>BGP</li>
</ul>
<p><img src="http://i.imgur.com/Oy9eKCM.png" alt=""></p>
<h4 id="10-4_RIP选路信息协议">10.4 RIP选路信息协议</h4>
<p><img src="http://i.imgur.com/EuX3zdr.png" alt=""></p>
<p>运行，RIP常用UDP端口是520</p>
<ul>
<li>初始化：启动一个守护程序，判断启动哪些接口，每个接口上发送一个请求报文，要求其他路由器发送完整路由表，命令字段为1，地址字段为0，度量字段16这事一份要求另一端完整路由表的特殊请求报文</li>
<li>接收到请求，处理请求中每一个表项</li>
<li>接受响应，更新路由表</li>
<li>定期选路更新，每过30秒，所有或者部分路由器发送完整路由表给相邻路由器，广播或者点对点</li>
<li>触发更新</li>
</ul>
<p>每个路由都有与之相关的定时器，如果rip发现系统中一条路有3分钟没有更新了，就设置为16，标注为删除</p>
<p>度量:<br>度量以跳hop计算，直接连接的接口跳数为1<br><img src="http://i.imgur.com/DkaACsB.png" alt=""><br>每个路由器都发送其路由表给相邻站，如果在AS内从一个路由器到一个网络有多条路由，选择跳数小的<br>跳数最大是15，16表示无法到达的ip地址</p>
<p>问题</p>
<ul>
<li>没有子网概念</li>
<li>发生故障后要很长时间稳定下来</li>
<li>度量15限制了rip的网络大小</li>
</ul>
<h4 id="10-5_RIP_版本2">10.5 RIP 版本2</h4>
<p>利用了版本1中必须为0的一些字段传递信息</p>
<p>选路域<br>选路标记<br>子网掩码<br>下一站ip地址</p>
<h4 id="10-6_OSPF开放最短路径优先">10.6 OSPF开放最短路径优先</h4>
<h4 id="10-7_BGP边界网关协议">10.7 BGP边界网关协议</h4>
<p>IGP:RIP<br>EGP:BGP<br>还在研究和发展</p>
<h3 id="第十一章_UDP">第十一章 UDP</h3>
<h4 id="11-1_引言">11.1 引言</h4>
<p>UDP是一个简单的面向数据报的运输层协议，进程的每个输出操作正好产生一个UDP</p>
<h4 id="11-2_UDP首部">11.2 UDP首部</h4>
<p><img src="http://i.imgur.com/av15yfg.png" alt=""></p>
<p>UDP长度字段指的是UDP首部和UDP数据的字节长度，最小为8个字节</p>
<h4 id="11-3_UDP检验和">11.3 UDP检验和</h4>
<p>UDP检验和覆盖UDP首部和UDP数据<br>IP首部检验和只覆盖IP的首部，不包括数据包中的任何数据</p>
<p>UDP检验和是可选的，UDP和TCP数据报都含有一个12字节的伪首部<br><img src="http://i.imgur.com/AFSLHAZ.png" alt=""></p>
<p>计算检验和为奇数长度就填充0<br>检验和计算为0，就存入全1<br>如果检验和为0，说明发送端没有计算检验和</p>
<p>UDP检验和(包括tcpip所有的检验和)是简单的16bit和，检验不出交换两个16bit的差错</p>
<p>不是所有的以太网数据帧都是ip数据报，至少还有arp协议<br>不是所有的ip数据报都是udp或tcp数据，icmp也用ip传送数据</p>
<h4 id="11-5_IP分片">11.5 IP分片</h4>
<ul>
<li>ip把mtu与数据报长度进行比较，如果需要分片，分片可以发生在发送端主机，也可以在中间路由器</li>
<li>每一份ip数据包分片以后，只有到达目的地才进行重新组装，组装由ip层完成，目的是让分片和充足对运输层透明</li>
<li>发送端发送的每份ip数据报，标识字段都包含一个唯一值，该值在数据报分片时被复制到每个片中。标识字段用其中一个比特标识“更多的片”，除了最后一篇，其他都是1。片偏移字段指的是该片偏移原始数据包开始处的位置，数据报备份片后，每个片的总长度都要改成改片的长度</li>
<li>标志字段有一个比特位“不分片”位，如果是1，ip将不对数据报进行分片，相反会丢弃并发送一个icmp差错报文（需要进行分片但设置了不分片比特）</li>
<li>被分片后，每个片都成为一个分组，都有自己的ip首部，路由时也是独立的，到达时时失序的，但是有足够信息重组</li>
<li>即使丢失一片数据，也要重传所有<br><img src="http://i.imgur.com/phWGLHP.png" alt=""><br>frag是标识字段的值<br>@前面是数据长度，后面是偏移量</li>
</ul>
<p><img src="http://i.imgur.com/GQ3KAlB.png" alt=""><br>分组和数据报区别</p>
<h4 id="11-6_ICMP不可达差错(需要分片)">11.6 ICMP不可达差错(需要分片)</h4>
<p>通过ping程序，逐步增加数据分组长度，知道看见进入的分组被分片为止</p>
<h4 id="11-7_Traceroute确定路径MTU">11.7 Traceroute确定路径MTU</h4>
<p>设置Traceroute不分片，逐步减小分组长度，如果路由器发送的icmp错误报文是新格式，包含出口的mtu，那就用这个作为下一个mtu值来发送，不用依次减少来不断测试</p>
<p>利用mtu发现机制，应用程序可以充分利用更大的mtu来发送报文</p>
<h4 id="11-8_采用udp的路径mtu发现">11.8 采用udp的路径mtu发现</h4>
<p>ip当知道发往该目的地址的数据报不能将DF比特置1，因此，ip要对数据报进行分片<br>建议每10分钟来查看MTU是不是变大了</p>
<h4 id="11-9_UDP和ARP之间的交互作用">11.9 UDP和ARP之间的交互作用</h4>
<p>当arp没有缓存时，发送一个8192自己的udp数据报，会产生6个数据报片—ip分片</p>
<p>每个分片都会有arp请求。<br>收到arp应答时，只将最后一个报文发送到制定目的主机<br>这事ARP洪范，arp flooding，高速率重复发送到同一个ip地址的arp请求</p>
<p>而且没有icmp组装超时差错<br>因为一般来说，第一个数据报片出现，ip必须启动一个定时器，30秒或者60秒，如果定时器超时那这个数据报的所有数据片未能全部到达，就全部丢弃</p>
<p>没看到有两个原因</p>
<ul>
<li>berkeley派生的不产生这个差错</li>
<li>没有接收到包含udp首部的偏移量为0的第一个数据报片，除非第一个数据报片到达，不然不知道运输层的首部，无法区分是哪个进程发送的数据报被丢弃</li>
</ul>
<p>大多数arp实现在等待arp应答时只保留最近传送给目的端的数据报</p>
<h4 id="11-10_最大UDP数据报长度">11.10 最大UDP数据报长度</h4>
<p>理论最大ip长度65535，取出首部是65507字节，但是有两个限制导致数值小</p>
<ol>
<li>应用程序可能会受到程序接口的限制</li>
<li>tcpip的内核实现限制</li>
</ol>
<h4 id="11-11_ICMP源站抑制差错source_quench">11.11 ICMP源站抑制差错source quench</h4>
<p>接受数据报的速度比处理的速度快，就可能产生这个差错<br>“可能”是因为即使一个系统没有缓存并丢弃数据报，可不要求它一定要发送源站抑制报文</p>
<p>新的RFC中，提出路由器不应该产生这个报文，因为他小号网络带宽，而且对拥塞来说是一种无效而且不公平的调整</p>
<h4 id="11-12_UDP服务器的设计">11.12 UDP服务器的设计</h4>
<p>通常一个客户启动后直接鱼单个服务器通信，然后就结束了，而对于服务器来说，它启动后处于休眠，等待客户请求的到来，对于udp，客户数据报到达时，服务器苏醒</p>
<p>需要客户ip地址和端口号</p>
<p>需要目的ip地址，因为有广播</p>
<p>UDP输入队列<br>单个服务器进程对单个udp端口上的所有客户请求进行处理<br>udp自动排队，接收到的udp数据报以其接受顺序给应用程序</p>
<p>排队会溢出</p>
<ul>
<li>应用程序不知道输入队列何时溢出，只是udp对超时数据报进行丢弃处理</li>
<li>没有发回任何信息告诉客户数据报被丢失</li>
<li>udp是fifo</li>
<li>arp是lifo</li>
</ul>
<p>可以限制本地ip地址的端口和远端ip地址的端口，通常一个程序端口与某个本地ip地址及udp端口号想关联</p>
<h3 id="第十二章_广播和多播">第十二章 广播和多播</h3>
<h4 id="12-1_引言">12.1 引言</h4>
<p>三种ip地址</p>
<ul>
<li>单播</li>
<li>广播</li>
<li>多播</li>
</ul>
<p>广播和多播仅仅用于tcp，他们对需要将报文同时传给多个接受者的应用十分重要。<br>tcp是一种面向连接的协议，是两个主机内的两个进程间的一个连接</p>
<p>广播:向网上的所有其他主机发送帧<br>多播:单播和广播之间</p>
<p>接口会被设置为混杂模式，这种模式能接收到每个帧的一个复制，如tcpdump</p>
<p>多播地址:01:00:00:00:00:00<br>广播地址:ff:ff:ff:ff:ff:ff</p>
<p>广播会增加对广播数据不感兴趣主机的处理负荷<br>多播减少了应用不感兴趣主机的处理负荷，使用多播可以加入一个或者多个多播组</p>
<h4 id="12-2_广播">12.2 广播</h4>
<p>受限的广播地址:255.255.255.255<br>该地址用于主机配置过程中ip数据报的目的地址<br>系统初始启动时用</p>
<p>任何情况，都不转发受限的，仅仅出现在本地网络中</p>
<p>指向网络的广播<br>A类,netid.255.255.255</p>
<p>指向子网<br>128.1.2.255<br>子网掩码255.255.255.0</p>
<p>指向所有子网的广播<br>128.1.255.255</p>
<h4 id="12-3_广播的例子">12.3 广播的例子</h4>
<p>相应广播前，发送arp请求</p>
<h4 id="12-4_多播">12.4 多播</h4>
<p>ip多播服务</p>
<ul>
<li>向多个目的地址传送数据</li>
<li>客户对服务器的请求</li>
</ul>
<p>能够接受王法一个特定多播组地址数据的主机集合成为主机组，一个主机组可以跨越多个网络，主机中的成员随时可以加入或者离开主机组，主机组对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送消息</p>
<p>多播组地址到以太网地址映射转换</p>
<h3 id="第十三章_IGMP:Internet_组管理协议">第十三章 IGMP:Internet 组管理协议</h3>
<p>多播的一组协议</p>
<h3 id="第十四章_DNS">第十四章 DNS</h3>
<h4 id="14-1_引言">14.1 引言</h4>
<p>主机名字和 ip 地址之间的转换<br>解析器通常是应用程序的一部分。在一个应用程序请求 TCP 打开一个连接或使用 UDP 发送一个数据报之前，必须将一个主机名转换成一个 IP 地址。操作系统内核中的 TCPIP 协议族对于 DNS 一点也不知道</p>
<h4 id="14-2_DNS_基础">14.2 DNS 基础</h4>
<p>FQDN(full qualified domain name)<br>顶级域名三部分</p>
<ul>
<li>arpa 用于地址到名字转换的特殊域</li>
<li>7个3字符的普通域</li>
<li>所有2字符的国家域名</li>
</ul>
<p><img src="http://i.imgur.com/RkcsLrt.png" alt=""></p>
<p>一个区域的管理者为该区域提供主名字服务器和至少一个辅助名字服务器。主，辅名字服务器必须是独立和冗余的。</p>
<p>每个名字服务器必须知道根的名字服务器。根服务器知道所有二级域中的每个授权名字服务器的名字和位置</p>
<p>超高速缓存</p>
<h4 id="14-3_DNS_报文格式">14.3 DNS 报文格式</h4>
<p><img src="http://i.imgur.com/0gWpaBd.png" alt=""></p>
<p>查询报文：<br><img src="http://i.imgur.com/zZkdavI.png" alt=""></p>
<p>相应报文<br><img src="http://i.imgur.com/K0nw3Su.png" alt=""></p>
<h4 id="14-4_简单的栗子">14.4 简单的栗子</h4>
<p>nslookup<br>dig</p>
<p>压缩回答报文</p>
<ul>
<li>返回的结果中包含查询的问题</li>
<li>在返回的结果中会有许多重复的域名，就要用到压缩<br>压缩方法就是用指针，最高位为11，他表示这是一个16bit 指针而不是8bit 的计数字节。指针中的剩下14bit 说明在该 DNS 报文中标识符所在的位置。<br>一个指针可能指向一个完整的域名，也可能指向一个域名的结尾部分。</li>
</ul>
<h4 id="14-5_指针查询">14.5 指针查询</h4>
<p>给定一个 ip 地址，返回与该地址相应的域名<br>顶级域名arpa 和下面 in-addr 域。当一个组织进入 internet，就获得 DNS 域名空间的授权<code>165.226.125.74.in-addr.arpa</code><br>DNS 名字是由 DNS 树的底部逐渐向上书写的</p>
<pre><code>➜  cs615 git:(master) host <span class="number">74</span>.<span class="number">125</span>.<span class="number">226</span>.<span class="number">165</span>                    
<span class="number">165</span>.<span class="number">226</span>.<span class="number">125</span>.<span class="number">74</span>.<span class="keyword">in</span>-<span class="keyword">addr</span>.arpa domain name <span class="type">pointer</span> lga15s45-<span class="keyword">in</span>-f5.<span class="number">1</span>e100.net.
</code></pre><p>如果 DNS 树中没有独立的分支来处理这种地址名字的转换，就无法反向转换</p>
<h4 id="14-6_资源记录">14.6 资源记录</h4>
<ul>
<li>A：ip 记录</li>
<li>PTR：指针记录查询，ip 地址被当做 in-addr.arpa 下的一个域名</li>
<li>CNAME：别名 alias，规范名字 canonical name</li>
<li>HINFO：主机信息</li>
<li>NS：名字服务器</li>
<li>MX：邮件交换记录,如果发往 <code>linliu.me</code>，会被提醒发送到<code>smtp.secureserver.net</code>。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  cs615 git:(master) host -t mx linliu.<span class="keyword">me</span> </div><div class="line">linliu.<span class="keyword">me</span> mail <span class="keyword">is</span> handled <span class="keyword">by</span> <span class="number">10</span> mailstore1.secureserver.net.</div><div class="line">linliu.<span class="keyword">me</span> mail <span class="keyword">is</span> handled <span class="keyword">by</span> <span class="number">0</span> smtp.secureserver.net.</div></pre></td></tr></table></figure>

<p><img src="http://i.imgur.com/ODuvld3.png" alt=""><br>第一列域名，第二列寿命值，ttl 为599秒，第三列 IN 就是 internet 类，然后就是类型，然后还有更高的优先值，0或10</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  cs615 git:(master) dig linliu.<span class="keyword">me</span></div><div class="line">;; ANSWER SECTION:</div><div class="line">linliu.<span class="keyword">me</span>.		<span class="number">599</span>	<span class="keyword">IN</span>	A	<span class="number">192.30</span><span class="number">.252</span><span class="number">.154</span></div><div class="line">linliu.<span class="keyword">me</span>.		<span class="number">599</span>	<span class="keyword">IN</span>	A	<span class="number">192.30</span><span class="number">.252</span><span class="number">.153</span></div></pre></td></tr></table></figure>

<h4 id="14-7_高速缓存">14.7 高速缓存</h4>
<p>高速缓存由 NS 维护。<br>host 命令指出回答不是授权的，因为这个回答来自NS 的高速缓存，而不是来自授权的 NS。</p>
<h4 id="14-8_UDP_还是_TCP">14.8 UDP 还是 TCP</h4>
<p>大部分时间用 udp<br>当长度超过时，用 tcp，辅助 ns 启动时，使用 tcp 问主ns 查询有没有变化，这里的传输数据很多</p>
<h3 id="第十五章_TFTP，简单文件传送协议">第十五章 TFTP，简单文件传送协议</h3>
<h3 id="第十七章_TCP">第十七章 TCP</h3>
<ol>
<li>面向连接</li>
<li>可靠的</li>
<li>字节流服务</li>
</ol>
<p>面向连接：</p>
<ul>
<li>交换数据钱要建立一个tcp连接，握手</li>
<li>仅有两方通信</li>
</ul>
<p>可靠:</p>
<ul>
<li>应用数据被tcp分割成合适的发送数据块</li>
<li>发送一个段后，启动定时器，等待目的端确认，不然重发</li>
<li>收到数据，发送一个确认</li>
<li>保持首部和数据的检验和</li>
<li>有可能失序，tcp进行重新排序可以</li>
<li>tcp接收端会丢弃重复数据</li>
<li>提供流量控制，有缓冲空间</li>
</ul>
<p>字节流:</p>
<ul>
<li>两个应用程序交换8bit的字节构成的字节流</li>
<li>tcp不对字节流内容做任何解释，应用层来解释，和unix操作系统的方式很像</li>
</ul>
<p><img src="http://i.imgur.com/HSuunq9.png" alt=""></p>
<p>20字节</p>
<ul>
<li>端口号：一个ip地址和一个端口号成为一个socket，两组这个就是一个唯一的tcp连接双方</li>
<li>序号用来标识从tcp端法相收端的数据字节流，对每个字节进行计数</li>
<li>确认序号包含发送确认的一段所期望的下一个序号，确认序号是上次已成功收到的数据字节序号加1，ack标志为1时有效</li>
<li>全双工服务，两个方向上独立进行传输，每一段都保持每个方向上的传输数据序号</li>
<li>首部长度，最多60字节</li>
<li><p>6个标志比特，多个同时为1<br><img src="http://i.imgur.com/kOAEIZ1.png" alt=""></p>
</li>
<li><p>窗口大小用来流量控制</p>
</li>
<li>强制检验和，tcp首部和tcp数据，还要用伪首部</li>
<li>urg为1时紧急指针有效</li>
<li>可选项中最常见的时mss，maximum segment size</li>
<li>数据部分是可选的，连接建立和终止时，双方报文段只有tcp首部，没有数据，超时时也是只有首部</li>
</ul>
<h3 id="第十八章_tcp连接的建立与终止">第十八章 tcp连接的建立与终止</h3>
<h4 id="18-2_建立和终止连接">18.2 建立和终止连接</h4>
<p>建立连接:三次握手</p>
<ul>
<li>发送SYN段，加上序号</li>
<li>发回SYN报文段，带上确认序号和自己的序号,一个 SYN 占用一个序号</li>
<li>对序号加1发回一个ack<br><img src="http://i.imgur.com/Qwp3BIe.png" alt="enter image description here"><br>初始序号初始化为1，每0.5秒增加64000</li>
</ul>
<p>终止:四次握手<br>因为tcp是半关闭，全双工，所以每次要单独关闭，要4次<br>一个 FIN 占用一个序号</p>
<h4 id="18-3_连接建立的超时">18.3 连接建立的超时</h4>
<p>第一次6秒，第二次24秒<br>默认建立时长是75秒，如果没有建立成功就放弃</p>
<p>使用定时器</p>
<h4 id="18-4_最大报文段长度">18.4 最大报文段长度</h4>
<p>MSS表示TCP传往另一端的最大块数据的长度，建立时要告诉对面各自的mss，一般来说越大越好，利用率最高，mss值设置为外出接口上的MTU长度减去固定的ip首部和tcp首部长度，一个以太网就是1460<br>mss选项只能出现在syn报文段中</p>
<p>接受到mss后，发送较小的mss，这样避免分段。如果接口的大，路径中有的比较小，那就要用MTU发现机制</p>
<h4 id="18-5_TCP的半关闭">18.5 TCP的半关闭</h4>
<p>TCP提供连接的一端在结束它的发送后还能接受来自另一端数据的能力<br>使用FIN</p>
<h4 id="18-6_TCP状态变迁图">18.6 TCP状态变迁图</h4>
<p><img src="http://i.imgur.com/UhV1JW4.png" alt=""></p>
<p>TIME_WAIT状态也称作2MSL等待状态，这个具体TCP实现必须选择一个报文段最大生存时间MSL，它是任何报文段被丢弃前在网络内的最长时间</p>
<p>结果是2MSL等待时TCP连接的socketip和端口不能再被使用，只有等结束后才能被使用，一般msl时间为30秒，1分钟，2分钟</p>
<p>TCP重启后MSL秒内不能建立任何连接，这个称为平静时间</p>
<h4 id="18-7_复位报文段">18.7 复位报文段</h4>
<ol>
<li><p>到不存在的端口的连接请求<br>产生复位的常见情况就是目的端口没有在监听</p>
</li>
<li><p>异常终止一个连接<br>FIN是有序释放<br>复位是异常释放<br>优点：</p>
</li>
</ol>
<ul>
<li>丢弃任何带发数据并且利器发送复位报文</li>
<li>另一端知道是异常关闭还是正常关闭，应用程序可以做响应<br>rst报文段包含序号和确认序号，另一端不会产生任何响应<br>收到rst的一方终止连接，并且通知应用层是异常结束</li>
</ul>
<ol>
<li>检测半打开连接<br>一边异常中断另一边不知道，就是板打开</li>
</ol>
<h4 id="18-8_同时打开">18.8 同时打开</h4>
<p>两个应用程序同时彼此执行主动打开，只建立一条连接<br>进行四次交换<br><img src="http://i.imgur.com/HdqbKhY.png" alt=""></p>
<h4 id="18-9_同时关闭">18.9 同时关闭</h4>
<p><img src="http://i.imgur.com/8AtB2gM.png" alt=""></p>
<h4 id="18-10_TCP选项">18.10 TCP选项</h4>
<h4 id="18-11_TCP服务器设计">18.11 TCP服务器设计</h4>
<p>并发的，多进程或者多线程</p>
<p>到达多个请求，服务器忙的时候，就有队列<br>没有空间的话就丢弃tcp报文，也不发回任何报文<br>队列满时，不理会syn，也不发出rst作为应答</p>
<h3 id="第十九章_tcp的交互数据流">第十九章 tcp的交互数据流</h3>
<h4 id="19-1_引言">19.1 引言</h4>
<p>交互数据:Telnet,Rlogin<br>成块数据:FTP,电子邮件，新闻</p>
<h4 id="19-2_交互式输入">19.2 交互式输入</h4>
<p>Rlogin 连接上键入交互命令,每一个交互按键都产生一个数据分组.<br>因此一个按键就有4个报文<br><img src="http://i.imgur.com/stGRQ7J.png" alt=""></p>
<p>可以合并按键确认和按键回显的报文一起发送,这样就只要3个报文</p>
<h4 id="19-3_经过时延的确认">19.3 经过时延的确认</h4>
<p>通常 tcp 在接收到数据时并不立即发送 ACK, 而是推迟发送,以便将 ACK 与需要演这个方向的数据一起发送,捎带 ACK, 大部分时延是200MS</p>
<h4 id="19-4_Nagle_算法">19.4 Nagle 算法</h4>
<p>Rlogin 连接每次发送41个字节长的分组,被称为<strong>小分组</strong><br>在广域网上,小分组太多会引起拥塞,所以使用 Nagle 算法</p>
<p>该算法要求一个TCP 连接上最多只能有一个违背确认的未完成的小分组,该分组的确认到达之前不能发送其他的小分组,相反 TCP 收集这些少量的分组,在确认到来时以一个分组的方式发出去.<br>算法是自适应的,确认的越快,数据发送越快.</p>
<p>在以太网中,回显时延比较快,所以很少使用这个算法.</p>
<p>在广域网中时延大,所以会使用到.客户只有在收到前一个数据的确认后才能发送已经收集的数据,16个字节只要9个报文段</p>
<p>客户端发送3个字节,但是回显1个,这说明服务器端还没有读取完另外两个,但是可以先发送确认的报文段</p>
<h4 id="小结">小结</h4>
<p>Rlogin 一个字节传送<br>Telnet 允许一行<br>小德报文段,使用经受时延的确认,减少报文段数据<br>减慢的广域网,使用 Nagle 算法减少报文段数目</p>
<h3 id="第二十章_TCP_的成块数据流">第二十章 TCP 的成块数据流</h3>
<h4 id="20-1_引言">20.1 引言</h4>
<p>滑动窗口协议是一种流量控制方法,该协议允许发送方在停止并等待确认钱可以连续发送多个分组</p>
<h4 id="20-2_正常的数据流">20.2 正常的数据流</h4>
<p>TCP 的滑动窗口协议,接收方不必确认每一个收到的分组, ACK 是累计的</p>
<p>使用窗口更新来标示窗口有新的空间</p>
<h4 id="20-3_滑动窗口">20.3 滑动窗口</h4>
<p>三个行为:</p>
<ul>
<li>合拢</li>
<li>张开</li>
<li>收缩,不建议使用<br><img src="http://i.imgur.com/0SNYnEl.png" alt=""></li>
</ul>
<p><img src="http://i.imgur.com/bSqySIk.png" alt=""></p>
<h4 id="20-4_窗口大小">20.4 窗口大小</h4>
<h4 id="20-5_PUSH标志">20.5 PUSH标志</h4>
<p>发送方使用该标志通知接收方将所受到的数据全部提交给接受进程,这里的数据包括鱼 PUSH 一起发送的数据以及接收方 TCP 已经为接受进程收到的其他数据。</p>
<p>一个好的 TCP 实现可以自行决定何时设置这个标志</p>
<p>每次写操作清空发送缓存时就发送 PUSH，因为是最后一个报文段</p>
<h4 id="20-6_慢启动">20.6 慢启动</h4>
<p>当发送方发送太多报文，中间的路由器必须缓存分组，这样会耗尽中间路由器的存储器空间，虽然接收方的还有很多缓存</p>
<p>慢启动 slow start 算法是观察新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作的</p>
<p>慢启动为 tcp 增加了一个窗口：拥塞窗口（congestion window），cwnd。</p>
<p>当建立tcp 连接时，拥塞窗口初始化为1个报文段，没收到一个 ACK，拥塞窗口增加一个报文段。<br>发送方取拥塞窗口与通告窗口中的最小值作为发送上限<br>拥塞窗口是发送方使用的流量控制<br>通告窗口是接收方使用的流量控制<br>启动时，是指数的增长关系<br>在某个点可能达到了互联网的容量，于是中间路由器开始丢弃分组，这就通知发送方它的拥塞窗口过大了。。。。就要用到超时重传机制</p>
<h4 id="20-7_成块数据的吞吐量">20.7 成块数据的吞吐量</h4>
<p>窗口大小，窗口流量控制，慢启动对于吞吐量的作用</p>
<p>一个分组的时间取决于两个因素</p>
<ul>
<li>传播时延</li>
<li>媒体速率的发送时延</li>
</ul>
<p>通路中，速率较慢时，发送时延主要作用<br>速度快的话就是传播时延主要作用</p>
<p>带宽时延乘积<br>capacity (bits) = bandwidth (bits/sec) x round-trip time (sec)</p>
<p>拥塞<br>当数据到达一个大的管道并向一个较小的管道，就会发生拥塞<br>当多个输入流到达一个路由器，而路由器的输出流小鱼这些输入流的总和时就会发生拥塞</p>
<h4 id="20-8_紧急方式">20.8 紧急方式</h4>
<h3 id="第二十一章_TCP_的超时与重传">第二十一章 TCP 的超时与重传</h3>
<h4 id="21-1_引言">21.1 引言</h4>
<p>数据丢失时，TCP 通过发送时设置一个定时器解决这个问题，定时器溢出时还没有收到确认，就重传。关键在于超时的间隔和如果确定重传的频率</p>
<p>4个不同的定时器：</p>
<ul>
<li>重传定时器用于希望收到另一端的确认，本节</li>
<li>坚持定时器使窗口大小信息保持不断流动，22节</li>
<li>保活定时器检测一个空闲连接的另一端合适崩溃或重启，23节</li>
<li>2MSL 定时器测量连接 TIME_WAIT 状态的时间，18.6</li>
</ul>
<h4 id="21-2_超时与重传的简单例子">21.2 超时与重传的简单例子</h4>
<p>使用“指数退避”的方法<br>3，6，12，24，48，多个64秒来进行再一次确认，最后9分钟后放弃，返回错误</p>
<h4 id="21-2_往返时间测量">21.2 往返时间测量</h4>
<p>往返时间 RTT 测量。</p>
<ol>
<li><p>最初<br>M：测量到的当前 RTT<br>$$R\gets \alpha R+(1-\alpha )M$$<br>a为0.9的平滑因子<br>RTO 超时重传时间<br>$$RTO=R\beta$$<br>$\beta$推荐为2<br>这种方法在 RTT 变化范围很大时，这个方法无法跟上这种变化，会引起不必要的重传，所以用到了<strong>方差</strong></p>
</li>
<li><p>改进<br>$$Err=M-A$$<br>$$A\gets A+gErr$$<br>$$D\gets D+h(|Err|-D)$$<br>$$RTO=A+4D$$<br>A是被平滑的 RTT<br>D室被平滑的均值方差<br>Err 是刚测到的测量结果鱼当前 RTT 估计值的差<br>g 起平均作用，取值1/8<br>偏差的增益 h，取值0.25<br>RTT 变化时，较大的偏差增益会让 RTO 快速上升</p>
</li>
</ol>
<p>karn 算法<br>发出分组时超时，发出多个重传的分组，接收到 ack 时不知道是哪一个，这就是重传多义性的问题<br>所以，当一个超时和重传发生时，在重传数据的确认最后到达时，不更新 rtt 估计器，因为不知道哪一个 ack 对应那次传输<br>由于数据被重传，rto 得到一个指数退避，在下一次传输时使用这个退避后的 rto，对一个没有被重传的报文，除非收到了一个确认，不要计算新的 rto</p>
<h4 id="21-4_往返时间_RTT_例子">21.4 往返时间 RTT 例子</h4>
<p>RTT 计算不是对所有的报文段<br>每个列检只测量一次 RTT 值，发送一个报文段是，如果定时器已经使用，那么这个报文段不会被计时，只有数据报文会被计时，ACK 是不会被计时的<br>当收到一个包含这个序号的确认后，定时器就会被关闭</p>
<p>RTT 估计的几个过程</p>
<ul>
<li>初始化，A和 D为0和3秒<br>RTO=A+2D=6s<br>初始化2D值在初始化时用，别的时候4D</li>
<li>当 SYN 需要重传时，第一次6秒<br>第二次的计算时间为<br>RTO=A+4D=12s<br>由于指数退避所以两倍24秒<br>当 ACK 重传到达，A 和 D不会更新，因为 Karn 算法，所以还是24秒，虽然有一个 ack 了</li>
<li>到达第一个报文 ack 时<br>A=M+0.5=1.5+0.5=2<br>D=A/2=1<br>RTO=A+4D=6s</li>
<li>第二个 ack 到达<br>按照公式来算 RTO=6.3125<br>浮点原因最后为6s</li>
</ul>
<h4 id="21-5_拥塞举例">21.5 拥塞举例</h4>
<p>收到3同样的 ack 时，重传<br>接收方不断产生一样的 ack，并且暂时保存接受到的失序数据</p>
<h4 id="21-6_拥塞避免算法">21.6 拥塞避免算法</h4>
<p>两种分组丢失的指示:发生超时和收到重复的确认<br>拥塞避免算法和慢启动算法要对每个连接维持两个变量</p>
<ul>
<li>一个拥塞窗口 cwnd</li>
<li>一个慢启动门限 ssthresh</li>
</ul>
<p>算法过程:</p>
<ul>
<li>对一个给定连接，初始化 cwnd 为一个报文段，ssthresh 为65535个字节</li>
<li>tcp 输出不能超过 cwnd 和接收方通告窗口的大小</li>
<li>发生拥塞时，ssthresh 被设置为当前窗口大小的一半(cwnd 和接收方通告窗口的最小值)，如果<strong>超时</strong>引起了拥塞，把 cwnd 设置为1个报文段，就是慢启动</li>
<li>当有数据确认时，增加 cwnd，增加的方法依赖于是慢启动还是拥塞避免，cwnd 小鱼 ssthresh 就是慢启动否则就是拥塞避免，慢启动一直持续到当拥塞发生时所处位置的一半的时候才停止转为拥塞避免</li>
</ul>
<p>慢启动:1，2，4，8，对每一个 ack 增加1<br>拥塞避免:每收到一个确认就讲 cwnd 增加1/cwnd，加薪增长，希望在一个往返时间内最多为 cwnd 增加一个报文段</p>
<h4 id="21-7_快速重传与快速恢复算法">21.7 快速重传与快速恢复算法</h4>
<p>收到失序的报文时，tcp 立即产生一个 ack，不应该被延迟，重复的 ack 目的是让对方知道收到的时一个失序的报文段。<br>收到3个 ack 时，崇春丢失的数据报文段，接下来不是慢启动算法而是拥塞避免算法，这就是快速恢复算法</p>
<p>算法实现</p>
<ol>
<li>收到3个重复的 ack，将 ssthresh 设置为当前拥塞窗口 cwnd 的一半，重传丢失的报文段，设置 cwnd 为 ssthresh 加上3被的报文段大小</li>
<li>每次收到一个重复的 ack，cwnd 增加一个报文段大小并发送一个分组，如果新的 cwnd 允许发送，例子中庸的时 cwnd 取值和未被确认的数据大小比较</li>
<li>下一个确认新数据的 ack 到达时，设置 cwnd 为 ssthresh。这是对第一个步骤的确认也是对中间报文段的确认，这一步采用拥塞避免</li>
</ol>
<h4 id="21-9_按每条路由进行度量">21.9 按每条路由进行度量</h4>
<p>tcp 连接关闭时可以记录下足够多的数据来统计</p>
<h4 id="21-10_icmp_差错">21.10 icmp 差错</h4>
<h3 id="待续">待续</h3>
<p>19.4.1<br>20.8</p>
<h3 id="第二十二章_TCP_的坚持定时器">第二十二章 TCP 的坚持定时器</h3>
<p>窗口为0时，发送方不发数据，接收方窗口大于0时，返回一个 ack，但是这个 ack 会丢失。这样就导致了死锁。<br>为了防止死锁，发送方使用一个坚持定时器来周期性向接收方查询，以发现窗口是否已经增大</p>
<p>当通告窗口为0，客户停止发送任何其他数据，这就引起了客户设置其坚持定时器，然后以指数退避的方法来不断发送询问，tcp 不会放弃发送窗口探查</p>
<p>糊涂窗口综合征：少量的数据将通过连接进行交换，而不是满长度。<br>接收方：</p>
<ul>
<li>不通告小窗口。接收方不通告一个比当前窗口大的窗口，除非窗口可以增加一个报文段大小或者可以增加接收方缓存的一半<br>发送方：</li>
<li>可以发送一个满长度的报文段</li>
<li>可以发送至少接收方通告窗口大小一半的报文段</li>
<li>能够发送手头的所有数据并且不希望接受 ack</li>
</ul>
<h3 id="第二十三章_TCP_的保活定时器">第二十三章 TCP 的保活定时器</h3>
<p>许多情况下一个服务器希望知道客户主机是否处于崩溃并关机或者崩溃又重启的状态，于是就提供了保活定时器</p>
<p>保活定时器比较有争议，有人认为不应该在 tcp 中实现，而是在应用层中实现</p>
<p>在连接两个端系统的网络出现零时鼓掌时候，保活选项会引起一个实际上很好的连接被终止</p>
<p>如果一个给定的连接两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段</p>
<ul>
<li>客户主机依然正常运行，并从服务器可达</li>
<li>客户主机已经崩溃，并且关闭或者正在重新启动</li>
<li>客户主机崩溃并已经重新启动</li>
<li>客户主机正常运行，但是服务器不可达</li>
</ul>
<h3 id="第二十四章_TCP_的未来和性能">第二十四章 TCP 的未来和性能</h3>
<h4 id="24-2_路径_MTU_发现">24.2 路径 MTU 发现</h4>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="TCP/IP_详解(卷1:协议)">TCP/IP 详解(卷1:协议)</h2>
<h3 id="第一章:概述">第一章:概述</h3>
<p>tcp/ip 四层协议:</p>
<ul>
<li>链路层：设备驱动程序及接口卡</li>
<li>网络层：处理分组在网络中的活动</li>
<li>运输层：为两台主机上的应用程序提供端到端的通信</li>
<li>应用层：处理应用程序细节]]>
    
    </summary>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Network" scheme="http://yoursite.com/categories/Network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用vim反向破解文件]]></title>
    <link href="http://yoursite.com/2015/03/10/%E5%88%A9%E7%94%A8vim%E5%8F%8D%E5%90%91%E7%A0%B4%E8%A7%A3%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2015/03/10/利用vim反向破解文件/</id>
    <published>2015-03-11T03:00:06.000Z</published>
    <updated>2015-03-12T21:20:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>前几天和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>聊到CS615的最后一次大作业，老师开放漏洞让我们去攻击学校的服务器占领首页，然后各小组之间24小时内互相攻击，于是去年做的时候他去服务器上偷偷事先把别人的ssh私钥下载下来了然后取得了胜利，放了一个超级马里奥的游戏上去。。。。。实在是太贱了。。。。</p>
<p>然后<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>继续吹比说，他的文件目录权限设置的特别好，即使一个group的也几乎啥都看不到，不信让我去看看，然后我就真的去看了看，这是配图。。</p>
<p><img src="http://i.imgur.com/IxFMTUW.png" alt="Imgur"></p>
<p>乍一看，除了几个作业的目录和无关紧要的配置文件，别的权限基本都不可读，全被设置好了，但是这一组文件引起了我的兴趣</p>
<p><img src="http://i.imgur.com/PTpwXsp.png" alt="Imgur"></p>
<a id="more"></a>
<h1 id="VIM">VIM</h1>
<p><code>.bashrc</code>也就是bash的配置文件，而<code>.bashrc.swo</code>是使用<strong>vim</strong>时留下的恢复文件，有时候由于各种原因，比如电脑断电，网络原因导致ssh链接断开等等，在编辑vim的时候异常退出了，vim还是能帮你恢复之前正在编辑但是还没有保存的文档，这种机制就需要vim自带的恢复文件，一般第一个恢复文件是叫<code>.swp</code>，第二个是<code>.swo</code>，当再次打开原来的文件时，就会提示你恢复文件。</p>
<p>而在这个系统中，<code>.bashrc</code>是不可读的，所以我自然不可能从这个文件下手，但是<code>.bashrc.swo</code>是可读的，所以我直接把这个文件拷贝了出来，想试试能不能恢复，我试图直接打开这个文件</p>
<pre><code><span class="keyword">vim</span> .bashrc.swo
</code></pre><p>但是结果都是乱码</p>
<p><img src="http://i.imgur.com/siXmHsLm.png" alt="Imgur"></p>
<p>于是我想试试能不能自己编写一个<code>同名空文件</code>，然后让vim自己的机制来恢复回来呢,于是。。。。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>touch .bashrc</div><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>mv .bashrc.swo .bashrc.swp</div><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>ll</div><div class="line">total <span class="number">25</span></div><div class="line">drwxr-xr-x+  <span class="number">2</span> lliu19 student     <span class="number">4</span> <span class="constant">Mar</span> <span class="number">10</span> <span class="number">23</span><span class="symbol">:</span><span class="number">28</span> .</div><div class="line">drwxr-xr-x+ <span class="number">12</span> lliu19 student    <span class="number">20</span> <span class="constant">Mar</span> <span class="number">10</span> <span class="number">23</span><span class="symbol">:</span><span class="number">28</span> ..</div><div class="line">-rw-r--r--+  <span class="number">1</span> lliu19 student     <span class="number">0</span> <span class="constant">Mar</span> <span class="number">10</span> <span class="number">23</span><span class="symbol">:</span><span class="number">28</span> .bashrc</div><div class="line">-rw-r--r--+  <span class="number">1</span> lliu19 student <span class="number">12288</span> <span class="constant">Mar</span> <span class="number">10</span> <span class="number">23</span><span class="symbol">:</span><span class="number">25</span> .bashrc.swp</div><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>vim .bashrc</div></pre></td></tr></table></figure>

<p><img src="http://i.imgur.com/208SiKw.png" alt="Imgur"></p>
<p>大功告成！！！</p>
<p>于是我成功反向恢复了他的配置文件，知道了他ec2的私钥文件地址和文件名，虽然光知道地址还是不能知道破解，但是通过vim自带的恢复机制破解了别人的文件，还是很爽的。。。</p>
<p><img src="http://i.imgur.com/8pSpjLR.png?1" alt="Imgur"></p>
<h1 id="WHY">WHY</h1>
<p>为什么这一招能奏效了，这和linux的权限设置有关，linux在默认创建文件时使用<code>umask</code>去配置权限，例如这是学校服务器的默认umask</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lliu19<span class="variable">@rainman</span><span class="symbol">:~/tmp</span> <span class="variable">$ </span>umask</div><div class="line"><span class="number">0022</span></div></pre></td></tr></table></figure>

<p>也就是说创建文件时默认的是去掉了w权限，保留了r+x权限，所以当在服务器上编辑文件时不小心留下了vim的恢复文件<code>.swp</code>时，就会有权限问题。</p>
<p>但是vim毕竟是老牌编辑器不会想不到这个问题，所以vim在生成<code>.swp</code>恢复文件时，和源文件是一样的读写权限，大家可以去试试。因此之所以会在服务器留下这个文件，有各种原因，有可能在设置权限时没想到有这么贱的方法，只修改了原来的权限，漏掉了vim的配置文件。</p>
<p>虽然这次只是破解了一个配置文件，但是vim编辑的文件里经常会有重要的配置，密码，密钥等等，所以还是要小心的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1>
<p>前几天和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>聊到CS615的最后一次大作业，老师开放漏洞让我们去攻击学校的服务器占领首页，然后各小组之间24小时内互相攻击，于是去年做的时候他去服务器上偷偷事先把别人的ssh私钥下载下来了然后取得了胜利，放了一个超级马里奥的游戏上去。。。。。实在是太贱了。。。。</p>
<p>然后<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>继续吹比说，他的文件目录权限设置的特别好，即使一个group的也几乎啥都看不到，不信让我去看看，然后我就真的去看了看，这是配图。。</p>
<p><img src="http://i.imgur.com/IxFMTUW.png" alt="Imgur"></p>
<p>乍一看，除了几个作业的目录和无关紧要的配置文件，别的权限基本都不可读，全被设置好了，但是这一组文件引起了我的兴趣</p>
<p><img src="http://i.imgur.com/PTpwXsp.png" alt="Imgur"></p>
]]>
    
    </summary>
    
      <category term="vim" scheme="http://yoursite.com/tags/vim/"/>
    
      <category term="security" scheme="http://yoursite.com/tags/security/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[程序员必备的开发工具---MAC]]></title>
    <link href="http://yoursite.com/2015/03/06/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-MAC/"/>
    <id>http://yoursite.com/2015/03/06/程序员必备的开发工具-MAC/</id>
    <published>2015-03-06T06:27:26.000Z</published>
    <updated>2015-03-06T19:24:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>用Mac也1年多了，前半年基本用来打游戏看电影了，由于mac基于unix而来，游戏比较少，好在我只玩dota2，所以对我来说，mac的娱乐性很足。</p>
<p>真正让我感觉离不开Mac的，是我这半年来的学习和开发，在<a href="http://yanguango.com" target="_blank" rel="external">yanguango</a>和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>的帮助下，对mac可以说有了全新的认识，也对linux编程，shell，vim有了更深入的了解。</p>
<h2 id="为什么选择Mac？">为什么选择Mac？</h2>
<p>对于一个程序猿来说，<strong>效率</strong>永远是第一位的，这不仅体现在学习的效率，还有工作编码的效率。在时间平等的情况下，如果才能有更多的<strong>产出</strong>，这一直是程序员所要思考进步的，如何节省<strong>时间</strong>来换取更高的产出呢?答案是——<a href="http://daily.zhihu.com/story/3387025" target="_blank" rel="external">能花钱的，就不要花时间</a></p>
<p>也许有的人说，Mac太贵，对一个还在上学的学生来说压力太大，确实，2000刀的一台mac对于学生党来说是不小的开支，但是如果你有能力，我<strong>极力</strong>劝你先入手一台mac，为什么呢？——<a href="http://www.cnblogs.com/chijianqiang/p/mmac.html" target="_blank" rel="external">先有 Mac 还是先有银元？</a></p>
<p>那有了Mac如何提高效率了，可以看看这篇文章——<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=206041450&amp;idx=1&amp;sn=3982c8cc45d7c47f0fbc19fe8371490f&amp;scene=0#rd" target="_blank" rel="external">程序员效率指南</a></p>
<p><strong>工欲善其事，必选利其器</strong></p>
<p>下面是我自己的一些经验分享，也是我最常使用的一些软件。<br><a id="more"></a></p>
<h2 id="应用&amp;效率">应用&amp;效率</h2>
<h3 id="Alfred_2"><a href="http://www.alfredapp.com/" target="_blank" rel="external">Alfred 2</a></h3>
<p><strong>必装</strong>，Mac下的神器之一，可以使用简单的命令完成相当多的事情</p>
<ul>
<li>定位文件</li>
<li>打开软件</li>
<li>计算器</li>
<li>查询api</li>
<li>google搜索</li>
<li>翻译单词</li>
<li>……</li>
</ul>
<p>自从用了它之后再也不用Dock了,打开应用，查东西比以前效率快<strong>几倍</strong>！<br>最关键的时他支持workflow插件，通过各式各样的<a href="http://www.zhihu.com/question/20656680" target="_blank" rel="external">插件</a>可以实现各种功能!</p>
<p><img src="http://i.imgur.com/pnugYMsm.png" alt="Imgur"><br><img src="http://i.imgur.com/C71WDmom.png" alt="Imgur"></p>
<h3 id="Evernote"><a href="https://evernote.com/premium" target="_blank" rel="external">Evernote</a></h3>
<p><strong>必装</strong>，平时找到的技术文章，牛人的随笔都可以记录下来,也可以自己写学习笔记，搜索也十分迅速<br>唯一的不足是有国际版和大陆版两种账号，而且不共享，我就吃了亏，国内的笔记没能同步过来。</p>
<p><img src="http://i.imgur.com/otbPVUim.png" alt="Imgur"></p>
<h3 id="Google_Driver"><a href="https://www.google.com/drive" target="_blank" rel="external">Google Driver</a></h3>
<p><strong>必装</strong>，平时分享文件，上传东西还在用qq群，U盘么？那你就太老土了，在这个资料日益珍贵的年代，我无法想象如果我的所有资料都没了，让我重头起家，那会是多么浩大的一个工程。<br>幸好现在有了许多免费的云存储服务，google driver免费的15G空间足够平时使用了，配合github基本上资料不会丢，最关键的是分享或者共同协作一些文章，会相当方便<br>同类：Dropbox</p>
<h3 id="1Password_5"><a href="https://agilebits.com/onepassword" target="_blank" rel="external">1Password 5</a></h3>
<p><strong>必装</strong>，最方便高效的密码管理器，这年头安全是多么重要，大家可不要像大表姐一样被泄露了艳照，嘿嘿。<br>这个软件有一个主密码，对每个不同的网站生成不同的密码进行管理，而且会自动填写页面的密码可以通过icloud或者Dropbox同步</p>
<p><img src="http://i.imgur.com/ncFptrU.png" alt="Imgur"></p>
<h3 id="Moom"><a href="http://manytricks.com/moom/" target="_blank" rel="external">Moom</a></h3>
<p><strong>推荐</strong>，窗口移动工具，对于程序来说，同时开几个窗口那是家常便饭，一个一个移动真是太麻烦了，好在这个软件完美的帮我们解决了问题</p>
<h3 id="Mou/MacDown"><a href="http://25.io/mou/" target="_blank" rel="external">Mou</a>/<a href="http://macdown.uranusjr.com/" target="_blank" rel="external">MacDown</a></h3>
<p><strong>推荐</strong>，可视化的md编辑器，其实用哪个都行，但是md没有统一的标准，所以不同编辑器的效果有可能不一样。</p>
<p><img src="http://i.imgur.com/FejLedt.png" alt="Imgur"></p>
<h3 id="Pocket"><a href="https://getpocket.com/" target="_blank" rel="external">Pocket</a></h3>
<p><strong>推荐</strong>，readerlater工具，保存网站文章或者微博文章，等有时间了就阅读一下，而且这个软件对移动端的支持非常好</p>
<h3 id="AppCleaner"><a href="http://www.freemacsoft.net/appcleaner/" target="_blank" rel="external">AppCleaner</a></h3>
<p><strong>推荐</strong>，清理软件的程序</p>
<h3 id="iStat_Menus"><a href="http://bjango.com/mac/istatmenus/" target="_blank" rel="external">iStat Menus</a></h3>
<p><strong>推荐</strong>，检测自己的电脑的各个参数，对于打游戏的同学，可以手动调风扇转速很方便</p>
<h2 id="开发">开发</h2>
<h3 id="Dash"><a href="http://kapeli.com/dash" target="_blank" rel="external">Dash</a></h3>
<p><strong>必装</strong>，查文档的工具，非常好用节省时间，配合alfred能快速查找api</p>
<p><img src="http://i.imgur.com/NHFJF6m.png" alt="Imgur"></p>
<h3 id="Homebrew"><a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a></h3>
<p><strong>必装</strong>，Mac下的包管理器，装东西卸载东西都很方便，一个命令 brew install就完事了，要卸载就brew uninstall</p>
<h3 id="zsh">zsh</h3>
<p><strong>必装</strong>，虽然Mac原装的bash已经很好用了，但是zsh的功能更加丰富，而且全面兼容bash，利用<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">oh-my-zsh</a>一键安装很方便，而且提供上百种插件，例如自带的git能alias相当多的git命令，还有神器z或者autojump，能记住cd进入过的目录，下一次进入的时候，只要z然后输出目录关键字就能到大，再也不用输出一串超级长的cd命令了。</p>
<h3 id="TotalTerminal"><a href="http://totalterminal.binaryage.com/" target="_blank" rel="external">TotalTerminal</a></h3>
<p><strong>推荐</strong>，一款不错的终端，可以通过快捷键下拉，我的时command+command，还提供标签和查询功能，比原生的terminal强大不少。</p>
<h3 id="CodeRunner"><a href="https://coderunnerapp.com/" target="_blank" rel="external">CodeRunner</a></h3>
<p><strong>推荐</strong>，测试一些小代码专用，比如想试试这个函数对不对啊，这个类怎么用啊都可以放进这个软件里跑，各种语言基本都支持。</p>
<p><img src="http://i.imgur.com/PgT7U7um.png" alt="Imgur"></p>
<h3 id="Hexo"><a href="http://hexo.io/" target="_blank" rel="external">Hexo</a></h3>
<p><strong>推荐</strong>，博客利器，关键我比较喜欢用md写东西，所以非常方便，原本用wordpress，但是感觉太繁重了，hexo比较轻量级，配置也方便。</p>
<h2 id="Editor—-VIM">Editor—-VIM</h2>
<p>我个人只用vim，所以就说一些插件的经验，emacs党可以跳过</p>
<h3 id="pathogen"><a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="external">pathogen</a></h3>
<p>插件管理器，很方便的管理自己的插件<br>同类：vundle</p>
<h3 id="nerdtree"><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="external">nerdtree</a></h3>
<p>编辑vim时可以树形查看自己的目录结构，分屏操作</p>
<h3 id="YouCompleteMe"><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">YouCompleteMe</a></h3>
<p>神级代码补全软件，google员工的作品，配置有点麻烦，但是相当好用</p>
<h3 id="ultisnips&amp;&amp;vim-snippets"><a href="https://github.com/SirVer/ultisnips" target="_blank" rel="external">ultisnips</a>&amp;&amp;vim-snippets</h3>
<p>定义了一些代码块，避免了很多重复劳动</p>
<p><img src="http://i.imgur.com/hqlcWNs.png" alt="Imgur"></p>
<h2 id="其他">其他</h2>
<h3 id="Popcorn-Time"><a href="https://popcorntime.io/" target="_blank" rel="external">Popcorn-Time</a></h3>
<p>老美也用的在线P2P高清1080P的电影的电视剧</p>
<h3 id="uTorrent"><a href="http://www.utorrent.com/" target="_blank" rel="external">uTorrent</a></h3>
<p>迅雷在美国封杀了，所以用这个，在海盗湾下载东西十分快，尤其是那些<strong>你懂得</strong>种子。</p>
<h3 id="Steam"><a href="http://store.steampowered.com/" target="_blank" rel="external">Steam</a></h3>
<p>已经有很多游戏支持Mac平台了，平时在上面玩dota2和csgo。</p>
<h2 id="后记">后记</h2>
<p>这几天联合<a href="http://yanguango.com" target="_blank" rel="external">yanguango</a>和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>对一个windows用户进行了深刻的宣传，像苍蝇一样盯着他说Mac有多好，多牛逼。。。。。最后这个同志在我们不厌其烦的劝导下，上纽约中央车站拿下了一台mac，哈哈哈哈哈哈。。。。</p>
<p><img src="http://i.imgur.com/nxFvrCa.png" alt="Imgur"></p>
<p>以上所有的软件均为正版，也请大家尊重程序员的劳动，支持正版！</p>
<p>今天正好下雪停课，本着共享开源的精神，写下了这些东西分享给大家，希望有帮助，如果还有哪些Mac下的神器我没发现，也请大家通过屏幕下方的联系方式告诉我，我也会不断更新，谢谢！</p>
<p>作者:lin<br>邮箱:liulin.jacob@gmail.com<br><a href="http://weibo.com/1939168341" target="_blank" rel="external">新浪微博</a><br><a href="https://github.com/liulin2012" target="_blank" rel="external">github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>用Mac也1年多了，前半年基本用来打游戏看电影了，由于mac基于unix而来，游戏比较少，好在我只玩dota2，所以对我来说，mac的娱乐性很足。</p>
<p>真正让我感觉离不开Mac的，是我这半年来的学习和开发，在<a href="http://yanguango.com" target="_blank" rel="external">yanguango</a>和<a href="http://wilbeibi.com" target="_blank" rel="external">wilbeibi</a>的帮助下，对mac可以说有了全新的认识，也对linux编程，shell，vim有了更深入的了解。</p>
<h2 id="为什么选择Mac？">为什么选择Mac？</h2>
<p>对于一个程序猿来说，<strong>效率</strong>永远是第一位的，这不仅体现在学习的效率，还有工作编码的效率。在时间平等的情况下，如果才能有更多的<strong>产出</strong>，这一直是程序员所要思考进步的，如何节省<strong>时间</strong>来换取更高的产出呢?答案是——<a href="http://daily.zhihu.com/story/3387025" target="_blank" rel="external">能花钱的，就不要花时间</a></p>
<p>也许有的人说，Mac太贵，对一个还在上学的学生来说压力太大，确实，2000刀的一台mac对于学生党来说是不小的开支，但是如果你有能力，我<strong>极力</strong>劝你先入手一台mac，为什么呢？——<a href="http://www.cnblogs.com/chijianqiang/p/mmac.html" target="_blank" rel="external">先有 Mac 还是先有银元？</a></p>
<p>那有了Mac如何提高效率了，可以看看这篇文章——<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=206041450&amp;idx=1&amp;sn=3982c8cc45d7c47f0fbc19fe8371490f&amp;scene=0#rd" target="_blank" rel="external">程序员效率指南</a></p>
<p><strong>工欲善其事，必选利其器</strong></p>
<p>下面是我自己的一些经验分享，也是我最常使用的一些软件。<br>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
      <category term="Mac" scheme="http://yoursite.com/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The prime contest]]></title>
    <link href="http://yoursite.com/2015/02/17/The-prime-contest/"/>
    <id>http://yoursite.com/2015/02/17/The-prime-contest/</id>
    <published>2015-02-17T06:37:34.000Z</published>
    <updated>2015-03-29T21:37:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Overview">Overview</h2>
<p>sum the primes from a to b, inclusive, a &lt; b &lt;= $10^{14}$.<br>Measure how long it takes your algorithm to sum the primes from 1 to $10^9$.<br>Determine the complexity of your algorithm and calculate how long it would take to sum for a=1, b = $10^{12}$.</p>
<h2 id="Algorithm">Algorithm</h2>
<p>I have used the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="external">Sieve_of_Eratosthenes </a>algorithm to delete the primes from the vector.<br><a id="more"></a></p>
<h2 id="Multi-thread">Multi-thread</h2>
<p>I have used the multithread technology to speed up the program.I have test some data.You can change the thread number to check the answer and find the best thread number in this experiment.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Data</th>
<th style="text-align:center">Thread number</th>
<th style="text-align:center">Execution time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1~$10^9$</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">0.6 Sec</td>
</tr>
<tr>
<td style="text-align:center">1~$10^{10}$</td>
<td style="text-align:center">5000</td>
<td style="text-align:center">6.8 Sec</td>
</tr>
<tr>
<td style="text-align:center">1~$10^{11}$</td>
<td style="text-align:center">10000</td>
<td style="text-align:center">90 Sec</td>
</tr>
</tbody>
</table>
<p><img src="http://i.imgur.com/f8dSURel.png" alt=""></p>
<p><img src="http://i.imgur.com/0NN7rXal.png" alt=""></p>
<p><img src="http://i.imgur.com/oNFQTwTl.png" alt=""></p>
<h2 id="Compiler_optimize">Compiler optimize</h2>
<pre><code><span class="comment">clang</span><span class="literal">+</span><span class="literal">+</span> <span class="literal">-</span><span class="comment">std=c</span><span class="literal">+</span><span class="literal">+</span><span class="comment">11</span>  <span class="literal">-</span><span class="comment">O2</span> <span class="comment">main</span><span class="string">.</span><span class="comment">cpp</span>
</code></pre><p>I have use the <code>-O2</code> to optimize the compiler and then</p>
<pre><code>./a.<span class="keyword">out</span>
</code></pre><p>This trick can <a href="https://msdn.microsoft.com/en-us/library/8f8h5cxt.aspx" target="_blank" rel="external">Maximize Speed</a> when compile the C++ code.</p>
<h2 id="Analyze">Analyze</h2>
<p>I have research on on the internet</p>
<blockquote>
<p>The bit complexity of the algorithm is O(n (log n) (log log n)) bit operations with a memory requirement of O(n).</p>
</blockquote>
<p>My result show above when I test the data $10^{9}$,$10^{10}$,$10^{11}$.Due to the algorithm complexity,I calculate the $10^{12}$ need to use 17 minute.</p>
<h2 id="Final">Final</h2>
<p>If you have any question,be free to contact me.Thank you!</p>
<ul>
<li>Author:lin</li>
<li>Email:liulin.jacob@gmail.com</li>
<li>Code Address:<a href="https://github.com/liulin2012/CPE593/blob/master/HW1b/main.cpp" target="_blank" rel="external">The prime contest</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Overview">Overview</h2>
<p>sum the primes from a to b, inclusive, a &lt; b &lt;= $10^{14}$.<br>Measure how long it takes your algorithm to sum the primes from 1 to $10^9$.<br>Determine the complexity of your algorithm and calculate how long it would take to sum for a=1, b = $10^{12}$.</p>
<h2 id="Algorithm">Algorithm</h2>
<p>I have used the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="external">Sieve_of_Eratosthenes </a>algorithm to delete the primes from the vector.<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="multithread" scheme="http://yoursite.com/tags/multithread/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Realize DHT Network through RESTful]]></title>
    <link href="http://yoursite.com/2014/11/07/realize-dht-network-through-restful/"/>
    <id>http://yoursite.com/2014/11/07/realize-dht-network-through-restful/</id>
    <published>2014-11-08T04:53:34.000Z</published>
    <updated>2015-03-06T19:27:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="1-DHT_Network">1.DHT Network</h1>
<blockquote>
<p>DHT(<a href="http://en.wikipedia.org/wiki/Distributed_hash_table" title="DHT" target="_blank" rel="external">Distributed Hash Tables</a>)is a class of a decentralized <a href="http://en.wikipedia.org/wiki/Distributed_computing" title="Distributed computing" target="_blank" rel="external">distributed system</a> that provides a lookup service similar to a <a href="http://en.wikipedia.org/wiki/Hash_table" title="Hash table" target="_blank" rel="external">hash table</a>; (<em>key</em>, <em>value</em>) pairs are stored in a DHT, and any participating <a href="http://en.wikipedia.org/wiki/Node_(networking" target="_blank" rel="external">node</a> “Node (networking)”) can efficiently retrieve the value associated with a given key. Responsibility for maintaining the mapping from keys to values is distributed among the nodes, in such a way that a change in the set of participants causes a minimal amount of disruption. This allows a DHT to scale to extremely large numbers of nodes and to handle continual node arrivals, departures, and failures.</p>
</blockquote>
<p>The key idea for the DHT network is utilize the pair(key,value) to  store and retrieve the data in distributed system.<br><a id="more"></a></p>
<p>1:Every resource has a unique<strong> pair(key,value)</strong> to distinguish.</p>
<p>2:System will use hash function to process every key,and use the result to determine where this resource should be stored in the DHT network.</p>
<p>3:When a user want to get the resource,use the same algorithm to hash the key and get the destination of the resource.</p>
<p>Maybe you didn’t know what I am saying now,but I will use the real model to realize this algorithm and then you will know the key idea about the DHT.After used this algorithm,the DHT network has a new key feature different from other distributed system like the GFS(<a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/10/The-Google-File-System.pdf" target="_blank" rel="external">The Google File System</a>).Every node(a computer in the DHT network) is both client and server,to responsible for a small route and storage in its area.So DHT don’t need a “super computer” to know everything in the system.This is why DHT is called <strong>decentralized distributed system.</strong></p>
<blockquote>
<p>Tips:In the GFS,system need to use a <strong>master</strong> to “control” everything.It needs to know all the information in the distributed system.Obviously,The <strong>master </strong>is the bottleneck in this system,but google has done a lot of optimize in the system,so it is very useful,more information about GFS,you can see the paper in the reference below.<br>&nbsp;</p>
</blockquote>
<p>In that case,DHT can be very scalability because it isn’t limited from the central control like the master in the GFS.So it is beneficial to store the huge amount of data in a distributed network.The famous application is the <a href="http://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="external">NoSQL</a> database such as <strong><a href="http://en.wikipedia.org/wiki/Apache_Cassandra" target="_blank" rel="external">Cassandra</a> </strong>by facebook and <a href="http://en.wikipedia.org/wiki/Dynamo_(storage_system" target="_blank" rel="external">Dynamo</a>) by Amazon.</p>
<p>There are a lot of different way to realize the DHT algorithm like Ring, Tree, Hypercube, Skip List, BuVerfly Network, …I have used the <a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer" target="_blank" rel="external">chord</a>) to do that because it is easy to explain and use.</p>
<p><img src="/images/c875063ffe4b73b15aa8d6d3e19c213c9b56437e.png" alt="45b48d324a1089fc21efa&amp;690"></p>
<p><strong>figure 1</strong></p>
<p>Step to realize the algorithm:</p>
<p>1:Every computer in the DHT network is a <strong>node</strong> which means it is responsible for store the data and route.In the figure1,each computer is represented as N1,N8,N14,N21……</p>
<p>2:Every resource is a <strong>pair(key,value).</strong>The resource can be everything such as the movie,music or the data in the application.The resource name will be hashed into a key and stored in a node.The resource is represented as K10,K24,K30…..The number is the key number of the resource.</p>
<p>3:The <strong>rule</strong> to store the resource in the computer(node) is that the resource is stored in the node which node number is <strong>bigger</strong> than resource key and the <strong>closest</strong> to that resource.For instance,the K10 need to store in N14 because N14 is bigger than 10 and N14 is the closest node to the K10.So K30 and K24 is stored in N32.In that case,once a new resource want to be stored in the DHT network,the resource name will be hashed into a key value and then use this value to determine where the resource should be stored.(This point is very <strong>important</strong> to understand the DHT network,if you can’t even understand what I am saying now,back to the step1 again.)</p>
<p><a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/11/45b48d324a1089fd1ebbdamp690.png" target="_blank" rel="external"><img src="/images/42aba3ce704bd922cb35b2ffa6cdf00647d7fdbe.png" alt="45b48d324a1089fd1ebbd&amp;690"></a></p>
<p>&nbsp;</p>
<p><strong>figure 2</strong></p>
<p>Now,you should know how to store a resource in a node.But how to realize it?</p>
<p><strong>rule</strong>:every node has its own finger table to route.FINGERN(i) = min {IDN2 | IDn2 ≥ IDn + 2^i (mod M)}</p>
<p>In the figure 2:</p>
<p>N8+1=N9,N9 belong to N14</p>
<p>N8+2=N10,N10 belong to N14</p>
<p>N8+8=N16,N16 belong to N21</p>
<p>For example,if one resource enter in the system and the key value is 22,so it is called K22.Once K22 enter in the system from the N8 and then retrieve the finger table,N8+8 is 16,N8+16 is 24.The K22 is between 16 and 24.So the K22 go to the 16 which is N21.And then use the N21 finger table to retrieve.</p>
<p>&nbsp;</p>
<p><a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/11/45b48d324a1089fffe1beamp690.png" target="_blank" rel="external"><img src="/images/59ebda1755c8399caa8871fe3b0f31c04fc245a8.png" alt="45b48d324a1089fffe1be&amp;690"></a></p>
<p>&nbsp;</p>
<p><strong>figure 3 </strong></p>
<p>If the key value is bigger than any number of the finger table,use the biggest one.Figure 3 show this condition.<a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/11/Screen-Shot-2014-11-08-at-01.52.25.png" target="_blank" rel="external"><img src="/images/3bef9e86b26304a922e1223c6d98e17b7b8ece1d.png" alt="Screen Shot 2014-11-08 at 01.52.25"></a></p>
<p><strong>figure 4</strong></p>
<p>Figure 4 show the detail about the route process.</p>
<blockquote>
<p>So,what is the <strong>algorithm complexity</strong>?It is same to the finger table size!With high probability, Chord contacts O(log N) nodes to find a successor in an N-node network.</p>
</blockquote>
<h1 id="2-RESTful">2.RESTful</h1>
<p>The RESTful(<a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external"><strong>Representational state transfer</strong></a>) is used to connect each node.It is easy to use because it only use the <strong>HTTP command</strong> which is familiar to us.Every node has RESTful client and server,so they can send the request to another and get the response.</p>
<p>In the client side,the client send the <strong>http request</strong> to the server side and get a Response from the server.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Response <span class="title">getRequest</span>(URI uri) {</div><div class="line">		<span class="keyword">try</span> {</div><div class="line">			Response cr = client.target(uri)</div><div class="line">					.request(MediaType.APPLICATION_XML_TYPE)</div><div class="line">					.header(Time.TIME_STAMP, Time.advanceTime())</div><div class="line">					.get();</div><div class="line">			processResponseTimestamp(cr);</div><div class="line">			<span class="keyword">return</span> cr;</div><div class="line">		} <span class="keyword">catch</span> (Exception e) {</div><div class="line">			error(&quot;Exception during GET request: &quot; + e);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line"><span class="keyword">public</span> String[] <span class="title">get</span>(NodeInfo n, String k) <span class="keyword">throws</span> Failed{</div><div class="line">		UriBuilder ub = UriBuilder.fromUri(n.addr);</div><div class="line">		URI getPath = ub.queryParam(&quot;key&quot;, k).build();</div><div class="line">		info(&quot;client get(&quot;+getPath+&quot;)&quot;);</div><div class="line">		Response response=getRequest(getPath);</div><div class="line">		<span class="keyword">if</span> (response == <span class="keyword">null</span> || response.getStatus() &gt;= <span class="number">300</span>) {</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> DHTBase.Failed(&quot;GET ?key=&quot;+k+&quot;addr=&quot;+n.addr);</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> response.readEntity(tableRowType).getValue().vals;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>In the server side,you can use the annotation to identify the path and response the request.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="annotation">@GET</span></div><div class="line"><span class="annotation">@Path</span>(&amp;quot;info&amp;quot;)</div><div class="line"><span class="annotation">@Produces</span>(&amp;quot;application/xml&amp;quot;)</div><div class="line"><span class="keyword">public</span> Response <span class="title">getNodeInfoXML</span>() {</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> NodeService(headers, uriInfo).getNodeInfo();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>The more detail about the RESTful you can see the wiki and the paper in the UCI.</p>
<h1 id="3-Final">3.Final</h1>
<p>This is my first time to write a English technology passage,so if you have found there are some errors or someplace you didn’t understand yet,please do not hesitate to contact me through the email <strong>liulin.jacob@gmail.com </strong>or leave a message below the passage.I am glad to receive your email.If you have some comment about my blog,I am appreciated to learn from you.</p>
<p>Thank you,have fun</p>
<p>lin</p>
<p>liulin.jacob@gmail.com</p>
<p>&nbsp;</p>
<p><strong>References:</strong></p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Distributed_hash_table" title="DHT" target="_blank" rel="external">Distributed Hash Tables</a></li>
<li><a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer" target="_blank" rel="external">chord</a>)</li>
<li><a href="http://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="external">NoSQL</a></li>
<li><a href="http://en.wikipedia.org/wiki/Apache_Cassandra" target="_blank" rel="external">Cassandra</a></li>
<li><a href="http://en.wikipedia.org/wiki/Dynamo_(storage_system" target="_blank" rel="external">Dynamo</a>)</li>
<li><a href="http://blog-linliu.rhcloud.com/wp-content/uploads/2014/10/The-Google-File-System.pdf" target="_blank" rel="external">The Google File System</a></li>
<li><a href="http://blog.csdn.net/opennaive/article/details/7483523" target="_blank" rel="external">谷歌技术”三宝”之谷歌文件系统</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_45b48d320100q6u7.html" target="_blank" rel="external">结构化P2P网络——DHT网络原理</a></li>
<li><a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external">Representational state transfer</a></li>
<li><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="external">Representational State Transfer (REST)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计指南</a></li>
</ul>
<h3 id="Related_articles_across_the_web">Related articles across the web</h3>
<ul>
<li><a href="http://blog.libtorrent.org/2014/11/dht-routing-table-maintenance/" target="_blank" rel="external"><img src="/images/c6b6bb93117a03074522e3292ed420c48fa495b8.jpg" alt=""></a><a href="http://blog.libtorrent.org/2014/11/dht-routing-table-maintenance/" target="_blank" rel="external">DHT routing table maintenance</a></li>
<li><a href="http://themindstorms.blogspot.com/2014/11/nosql-nosql-databases-hadoop-big-data.html" target="_blank" rel="external"><img src="/images/ac855e72b11d34da1bb518f43d6e000380c53f47.jpg" alt=""></a><a href="http://themindstorms.blogspot.com/2014/11/nosql-nosql-databases-hadoop-big-data.html" target="_blank" rel="external">NoSQL: NoSQL databases, Hadoop, Big Data: Pinned tabs Nov.3rd</a></li>
<li><a href="http://www.databasetube.com/nosql/dynamic-dynamos-comparing-riak-and-cassandra/" target="_blank" rel="external"><img src="/images/5a14a111c81e9492df286ed237beb7c84978d2ef.jpg" alt=""></a><a href="http://www.databasetube.com/nosql/dynamic-dynamos-comparing-riak-and-cassandra/" target="_blank" rel="external">Dynamic Dynamos: Comparing Riak and Cassandra</a></li>
<li><a href="http://www.hakkalabs.co/articles/eventbrite-recommendation-engine-apache-cassandra-2/" target="_blank" rel="external"><img src="/images/1772745eefe96420fd3a003d9d75fd46980dbba9.jpg" alt=""></a><a href="http://www.hakkalabs.co/articles/eventbrite-recommendation-engine-apache-cassandra-2/" target="_blank" rel="external">Eventbrite Recommendation Engine on Apache Cassandra</a></li>
<li><a href="http://cloudcelebrity.wordpress.com/2014/10/20/the-present-and-future-of-hadoop-from-its-creator-doug-cutting/" target="_blank" rel="external"><img src="/images/082126dfc9c351850e17320faab33fc5b1bd1cfb.jpg" alt=""></a><a href="http://cloudcelebrity.wordpress.com/2014/10/20/the-present-and-future-of-hadoop-from-its-creator-doug-cutting/" target="_blank" rel="external">The present and future of Hadoop from its creator Doug Cutting</a></li>
<li><a href="http://www.programmableweb.com/news/opendirect-api-standardizes-digital-ad-trading/elsewhere-web/2014/11/06" target="_blank" rel="external"><img src="/images/be783f37a738995347c6672aa3ee7cf3558d1834.jpg" alt=""></a><a href="http://www.programmableweb.com/news/opendirect-api-standardizes-digital-ad-trading/elsewhere-web/2014/11/06" target="_blank" rel="external">OpenDirect API Standardizes Digital Ad Trading</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="1-DHT_Network">1.DHT Network</h1>
<blockquote>
<p>DHT(<a href="http://en.wikipedia.org/wiki/Distributed_hash_table" title="DHT" target="_blank" rel="external">Distributed Hash Tables</a>)is a class of a decentralized <a href="http://en.wikipedia.org/wiki/Distributed_computing" title="Distributed computing" target="_blank" rel="external">distributed system</a> that provides a lookup service similar to a <a href="http://en.wikipedia.org/wiki/Hash_table" title="Hash table" target="_blank" rel="external">hash table</a>; (<em>key</em>, <em>value</em>) pairs are stored in a DHT, and any participating <a href="http://en.wikipedia.org/wiki/Node_(networking" target="_blank" rel="external">node</a> “Node (networking)”) can efficiently retrieve the value associated with a given key. Responsibility for maintaining the mapping from keys to values is distributed among the nodes, in such a way that a change in the set of participants causes a minimal amount of disruption. This allows a DHT to scale to extremely large numbers of nodes and to handle continual node arrivals, departures, and failures.</p>
</blockquote>
<p>The key idea for the DHT network is utilize the pair(key,value) to  store and retrieve the data in distributed system.<br>]]>
    
    </summary>
    
      <category term="DHT" scheme="http://yoursite.com/tags/DHT/"/>
    
      <category term="RESTful" scheme="http://yoursite.com/tags/RESTful/"/>
    
      <category term="Cloud Computing" scheme="http://yoursite.com/categories/Cloud-Computing/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello,Everyone]]></title>
    <link href="http://yoursite.com/2014/10/09/helloeveryone/"/>
    <id>http://yoursite.com/2014/10/09/helloeveryone/</id>
    <published>2014-10-10T00:30:40.000Z</published>
    <updated>2015-02-17T04:46:43.000Z</updated>
    <content type="html"><![CDATA[<p>Hello,everyone,I am lin liu,come from China My major is computer science and I am studying in America now.</p>
<p>Soccer and Dota2 are my favorite sports.Besides that,I am also fond of studying the computer science technology ,especially the cloud computing and algorithm.</p>
<p>This blog will be updated in an indefinite schedule,including the technology passage,studying experience,life record and so on.The passage will be written in English,sometimes both in English and Chinese.Due to my poor English,maybe I will write some sentences you can’t understand.Please calm down,do not fuck me.I am learning. lol</p>
<p>Finally,thank you for your coming.Good luck,have fun~~</p>
<p>&nbsp;</p>
<p>大家好，我是刘霖，来自中国，CS专业苦逼码农一枚，现在在大美帝专心读书。</p>
<p>平时酷爱踢足球打Dota2，没事钻研一下技术，现在主要学习云计算以及算法方面的知识,</p>
<p>本博客不定时更新文章，包括技术文章，学习心得，生活记录等等，经常拖稿和跳票，一般写英文的，有时候也会中英文双语，看心情。。。嘿嘿。。。由于英语水平不过关，经常会出现chiglish的情况，大家不要喷我，我也在慢慢学习之中。</p>
<p>最后谢谢大家来到我的博客，Have fun~~</p>
<p>&nbsp;</p>
<p>Lin</p>
<p>liulin.jacob@gmail.com</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Hello,everyone,I am lin liu,come from China My major is computer science and I am studying in America now.</p>
<p>Soccer and Dota2 are my]]>
    </summary>
    
      <category term="Daily life" scheme="http://yoursite.com/categories/Daily-life/"/>
    
  </entry>
  
</feed>
